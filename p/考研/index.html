<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="878 分析"><title>考研</title><link rel=canonical href=https://example.com/p/%E8%80%83%E7%A0%94/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="考研"><meta property="og:description" content="878 分析"><meta property="og:url" content="https://example.com/p/%E8%80%83%E7%A0%94/"><meta property="og:site_name" content="sy ^_^"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2023-03-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-26T00:00:00+00:00"><meta name=twitter:title content="考研"><meta name=twitter:description content="878 分析"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/head_portrait_hu1368e4ffa06e7513186f849074288e92_335306_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>sy ^_^</a></h1><h2 class=site-description>最是人间留不住，朱颜辞镜花辞树</h2></div></header><ol class=social-menu><li><a href='https://github.com/clumsy-sy?tab=repositories' target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/%E5%85%B3%E4%BA%8E/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><li><a href=/%E9%93%BE%E6%8E%A5/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>链接</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#考查目标>Ⅰ考查目标</a></li><li><a href=#考试形式和试卷结构>Ⅱ考试形式和试卷结构</a><ol><li><a href=#一试卷满分及考试时间>一、试卷满分及考试时间</a></li><li><a href=#二答题方式>二、答题方式</a></li><li><a href=#三试卷内容结构>三、试卷内容结构</a></li><li><a href=#四试卷题型结构>四、试卷题型结构</a></li></ol></li><li><a href=#考查范围>Ⅲ考查范围</a><ol><li><a href=#程序设计基础c>程序设计基础(C)</a></li><li><a href=#第一级>第一级</a></li><li><a href=#第二级>第二级</a></li><li><a href=#第三级>第三级</a></li><li><a href=#第四级>第四级</a></li><li><a href=#第五级>第五级</a></li><li><a href=#第六级>第六级</a></li><li><a href=#第七级>第七级</a></li><li><a href=#第八--十二级>第八 ~ 十二级</a></li><li><a href=#第十三级>第十三级</a></li><li><a href=#第十四级>第十四级</a></li><li><a href=#第十五级>第十五级</a><ol><li><a href=#一数据表达与组织>一、数据表达与组织</a></li><li><a href=#二语句及流程控制>二、语句及流程控制</a></li><li><a href=#三程序结构和函数>三、程序结构和函数</a></li><li><a href=#四输入输出和文件>四、输入/输出和文件</a></li><li><a href=#五编译预处理和命令行参数>五、编译预处理和命令行参数</a></li><li><a href=#六基本算法设计与程序实现>六、基本算法设计与程序实现</a></li></ol></li><li><a href=#数据结构>数据结构</a><ol><li><a href=#一栈队列和数组>一、栈、队列和数组</a></li><li><a href=#二树与二叉树>二、树与二叉树</a></li><li><a href=#三图>三、图</a></li><li><a href=#四动态查找>四、动态查找</a></li><li><a href=#五排序>五、排序</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%80%83%E7%A0%94/>考研</a></h2><h3 class=article-subtitle>878 分析</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Mar 26, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 27 分钟</time></div></footer></div></header><section class=article-content><h1 id=2023年浙江大学研究生入学考试>2023年浙江大学研究生入学考试</h1><p>——<a class=link href=http://www.cst.zju.edu.cn/2022/0922/c32178a2634571/page.htm target=_blank rel=noopener>《计算机专业基础》(878) 考试大纲</a></p><h2 id=考查目标>Ⅰ考查目标</h2><p>《计算机专业基础》(878) 综合考试涵盖程序设计、数据结构两门专业基础课程.要考生比较系统地掌握上述专业基础课程的基本概念、基本原理和基本方法, 能够综合运所学的基本原理和基本方法分析、判断和解决有关理论问题和实际问题.</p><h2 id=考试形式和试卷结构>Ⅱ考试形式和试卷结构</h2><h3 id=一试卷满分及考试时间>一、试卷满分及考试时间</h3><p>本试卷满分为150分, 考试时间为180分钟</p><h3 id=二答题方式>二、答题方式</h3><p>答题方式为闭卷、笔试</p><h3 id=三试卷内容结构>三、试卷内容结构</h3><p>程序设计基础(C) 60分
数据结构90分</p><h3 id=四试卷题型结构>四、试卷题型结构</h3><p>单项选择题70分(35小题, 每小题2分)</p><p>综合应用题80分</p><h2 id=考查范围>Ⅲ考查范围</h2><h3 id=程序设计基础c>程序设计基础(C)</h3><p>【考查目标】</p><ol><li>理解C程序设计语言结构, 掌握数据表示和输入输出的基本方法, 掌握流程控制、函数设计与调用方法;</li><li>理解模块化程序设计方法, 掌握基本的C语言程序设计过程和技巧;</li><li>掌握初步的算法设计及数据组织方法, 具备基本的问题分析和利用C语言进行求解问题的能力.</li></ol><h3 id=第一级>第一级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>[]</code></td><td>数组下标</td><td>数组名字[常量表达式]</td><td>左到右</td></tr><tr><td><code>()</code></td><td>圆括号</td><td>表达式 或 函数名(形参)</td><td>左到右</td></tr><tr><td><code>.</code></td><td>取成员</td><td>对象 . 成员名</td><td>左到右</td></tr><tr><td><code>-></code></td><td>成员选择(指针)</td><td>对象指针 <code>-></code> 成员名</td><td>左到右</td></tr></tbody></table></div><h3 id=第二级>第二级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>-</code></td><td>负号运算符</td><td>- 表达式</td><td>右到左</td></tr><tr><td><code>~</code></td><td>按位取反运算符</td><td>~ 表达式</td><td>右到左</td></tr><tr><td><code>++</code></td><td>自增运算符</td><td>++ 表达式 ++</td><td>右到左</td></tr><tr><td><code>--</code></td><td>自减运算符</td><td>&ndash; 表达式 &ndash;</td><td>右到左</td></tr><tr><td><code>*</code></td><td>取值运算符</td><td>* 指针变量</td><td>右到左</td></tr><tr><td><code>&</code></td><td>取地址运算符</td><td>& 变量名</td><td>右到左</td></tr><tr><td><code>!</code></td><td>逻辑非运算符</td><td>! 表达式</td><td>右到左</td></tr><tr><td><code>(类型)</code></td><td>强制类型转换</td><td>(数据类型) 表达式</td><td>右到左</td></tr><tr><td><code>sizeof</code></td><td>长度运算符</td><td>sizeof(表达式)</td><td>右到左</td></tr></tbody></table></div><h3 id=第三级>第三级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>/</code></td><td>除</td><td>表达式 / 表达式</td><td>左到右</td></tr><tr><td><code>*</code></td><td>乘</td><td>表达式 * 表达式</td><td>左到右</td></tr><tr><td><code>%</code></td><td>按位取反运算符</td><td>% 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第四级>第四级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>+</code></td><td>加</td><td>表达式 + 表达式</td><td>左到右</td></tr><tr><td><code>-</code></td><td>减</td><td>表达式 - 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第五级>第五级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>变量 &#171; 表达式</td><td>左到右</td></tr><tr><td><code>>></code></td><td>右移</td><td>变量 &#187; 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第六级>第六级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>></code></td><td>大于</td><td>表达式 > 表达式</td><td>左到右</td></tr><tr><td><code>>=</code></td><td>大于等于</td><td>表达式 >= 表达式</td><td>左到右</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td>表达式 &lt; 表达式</td><td>左到右</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td>表达式 &lt;= 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第七级>第七级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td>表达式 == 表达式</td><td>左到右</td></tr><tr><td><code>!=</code></td><td>不等于</td><td>表达式 != 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第八--十二级>第八 ~ 十二级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>&</code></td><td>按位与</td><td>表达式 & 表达式</td><td>左到右</td></tr><tr><td><code>^</code></td><td>按位异或</td><td>表达式 ^ 表达式</td><td>左到右</td></tr><tr><td><code>|</code></td><td>按位或</td><td>表达式 | 表达式</td><td>左到右</td></tr><tr><td><code>&&</code></td><td>逻辑与</td><td>表达式 && 表达式</td><td>左到右</td></tr><tr><td><code>||</code></td><td>逻辑或</td><td>表达式 || 表达式</td><td>左到右</td></tr></tbody></table></div><h3 id=第十三级>第十三级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>?:</code></td><td>条件运算符</td><td>表达式 1 ？表达式 2 : 表达式 3</td><td>右到左</td></tr></tbody></table></div><h3 id=第十四级>第十四级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值运算符</td><td>变量 = 表达式</td><td>右到左</td></tr><tr><td><code>/=</code></td><td>除后赋值</td><td>变量 /= 表达式</td><td>右到左</td></tr><tr><td><code>*=</code></td><td>乘后赋值</td><td>变量 ** 表达式</td><td>右到左</td></tr><tr><td><code>%=</code></td><td>取模赋值</td><td>变量 %% 表达式</td><td>右到左</td></tr><tr><td><code>+=</code></td><td>加后赋值</td><td>变量 ++ 表达式</td><td>右到左</td></tr><tr><td><code>-=</code></td><td>减后赋值</td><td>变量 &ndash; 表达式</td><td>右到左</td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移后赋值</td><td>变量 &#171;= 表达式</td><td>右到左</td></tr><tr><td><code>>>=</code></td><td>右移后赋值</td><td>变量 &#187;= 表达式</td><td>右到左</td></tr><tr><td><code>&=</code></td><td>按位与后赋值</td><td>变量 &= 表达式</td><td>右到左</td></tr><tr><td><code>^=</code></td><td>按位异或后赋值</td><td>变量 ^= 表达式</td><td>右到左</td></tr><tr><td><code>|=</code></td><td>按位或后赋值</td><td>变量 |= 表达式</td><td>右到左</td></tr></tbody></table></div><h3 id=第十五级>第十五级</h3><div class=table-wrapper><table><thead><tr><th>运算符</th><th>含义</th><th>使用</th><th>结合方向</th></tr></thead><tbody><tr><td><code>,</code></td><td>逗号运算符</td><td>变量 , 表达式</td><td>左到右</td></tr></tbody></table></div><p>同级依照结合方向顺序.</p><h4 id=一数据表达与组织>一、数据表达与组织</h4><p>(一) 常量, 变量, 运算与表达式
(二) 一维和二维数组, 字符数组和字符串
(三) 指针与数组, 结构与数组
(四) 指针与结构, 单向链表</p><h4 id=二语句及流程控制>二、语句及流程控制</h4><p>(一) 复合语句
(二) 分支控制(if、switch)
(三) 循环控制(for、while、do—while)</p><h4 id=三程序结构和函数>三、程序结构和函数</h4><p>(一) C程序结构
(二) 函数的定义、参数传递和调用
(三) 函数的递归调用
(四) 变量的存储类别、作用域, 全局变量和局部变量</p><h4 id=四输入输出和文件>四、输入/输出和文件</h4><p>(一) 标准输入和输出
(二) 文本文件与二进制文件
(三) 文件打开、关闭、读写和<strong>定位</strong></p><h4 id=五编译预处理和命令行参数>五、编译预处理和命令行参数</h4><p>(一) <strong>宏定义和宏函数</strong>
(二) <strong>命令行参数</strong>和使用</p><h4 id=六基本算法设计与程序实现>六、基本算法设计与程序实现</h4><p>(一) 简单排序算法(插入、选择、冒泡) 、二分查找
(二) 链表、文件中查找
(三) 级数求和、进制转换</p><blockquote><p>查找
<strong>平均查找长度</strong> : 设找到集合中第 <code>i</code> 个记录的概论是 $p_i(\sum_{i=0}^{N-1} p_i = 1)$ 且需要 <code>n_i</code> 次才很找到, 则平均查找长度为 $\sum_{i=0}^{N-1} p_i n_i = 1$</p></blockquote><p>二分查找</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define NotFound 0
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>Position</span> <span class=nf>BinarySearch</span><span class=p>(</span><span class=n>List</span> <span class=n>Tb1</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>,</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>Tb1</span> <span class=o>-&gt;</span> <span class=n>Last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>K</span> <span class=o>&lt;</span> <span class=n>Tb1</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>mid</span><span class=p>])</span> <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>K</span> <span class=o>&gt;</span> <span class=n>Tb1</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>mid</span><span class=p>])</span> <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>return</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>NotFound</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=数据结构>数据结构</h3><p>【考查目标】</p><ol><li>掌握数据结构的基本概念、基本原理和基本方法;</li><li>掌握数据的逻辑结构、存储结构及基本操作的实现, 能够对算法进行基本的<strong>时间复杂度与空间复杂度</strong>的分析;</li><li>能应用数据结构基本原理和方法进行问题的分析与求解, 具备采用C或C++语言设计与实现算法的能力.</li></ol><h4 id=一栈队列和数组>一、栈、队列和数组</h4><p>类型: 线性表
概念: 表头, 表尾, 前驱, 后继</p><p><strong>顺序存储实现</strong>
从下表 <code>0</code> 开始存, <code>Last</code>指向最后一个元素所在位置</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>ElementType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Position</span><span class=p>;</span> <span class=cm>/* 数组下标 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>LNode</span><span class=o>*</span> <span class=n>PtrToLNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>LNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>[</span><span class=n>MAXSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>Last</span><span class=p>;</span> <span class=cm>/* 记录线性表的最后一个元素所在位置(初始 -1)  */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToLNode</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>List</span> <span class=nf>MakeEmpty</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>=</span> <span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>LNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Position</span> <span class=nf>Find</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>&amp;&amp;</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>X</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span><span class=p>)</span> <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 在为序 i 前插入一个新元素 */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>==</span> <span class=n>MAXSIZE</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;表满&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;位序不合法&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>--</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 删除为序为 i 的元素 */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;位序不合法&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span><span class=p>;</span> <span class=n>j</span> <span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>-&gt;</span> <span class=n>Last</span> <span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>链式存储实现</strong>
没有头节点！<code>header</code>指针直接指向第一个元素</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>ElementType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>LNode</span> <span class=o>*</span> <span class=n>PtrToLNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>LNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToLNode</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToLNode</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToLNode</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Length</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 查找第 k 个元素 */</span>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>FindKth</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>&amp;&amp;</span> <span class=n>cnt</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>cnt</span> <span class=o>==</span> <span class=n>K</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 查找第一个值为 X 的元素的地址 */</span>
</span></span><span class=line><span class=cl><span class=n>Position</span> <span class=nf>Find</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>p</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>!=</span> <span class=n>X</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 在指定为序 i 前插入元素 X, 如果该链表有空的头节点, 则可省略 i==1 的特判 */</span>
</span></span><span class=line><span class=cl><span class=n>List</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>tmp</span><span class=p>,</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tmp</span> <span class=o>=</span> <span class=p>(</span><span class=n>Position</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>LNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>pre</span> <span class=o>&amp;&amp;</span> <span class=n>cnt</span> <span class=o>&lt;</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pre</span> <span class=o>=</span> <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>cnt</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pre</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>cnt</span> <span class=o>!=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;插入位置参数错误！&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>free</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 删除为序为 i 的元素 */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>tmp</span><span class=p>,</span> <span class=n>pre</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>pre</span> <span class=o>&amp;&amp;</span> <span class=n>cnt</span> <span class=o>&lt;</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>=</span> <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pre</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>cnt</span> <span class=o>!=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;插入位置参数错误！&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>(一) 栈和队列的基本概念</p><blockquote><p>栈 <code>Stack</code>(后入先出 <code>First In Last OUT</code>)</p><p>应用:</p><p>全排列 <code>n!</code> .</p><p>后缀表达式的计算.</p><p>将中缀表达式转化为后缀表达式(注意: 1.运算数直接输出 2.左括号入栈 3.遇到右括号一直弹出栈内运算符直到左括号(左右括号弹出但不用输出) 4. 运算符小于等于栈顶运算符则一直输出栈顶直到该运算符大于栈顶为止 5.处理完毕, 栈内全部输出) .</p><p>迷宫问题(模拟 DFS) ,函数调用和递归实现</p></blockquote><blockquote><p>队列 <code>Queue</code>(先进先出 <code>First In First OUT</code>)</p><p>简单法: <code>Front</code> 放数组下标小的, <code>Rear</code> 放大的, 容易出现‘假溢出’.</p><p>循环队列: <strong><code>Front = Rear = 0</code></strong>, 元素个数 <code>n + 1</code> 种情况, 但是 <code>Front</code> 与 <code>Rear</code> 之间差距最多 <code>n</code> 种情况.</p><p>法一: 增设变量 <code>Size</code> , 或最后一次操作是什么入队还是出队的 <code>Flag</code> .</p><p><strong>法二</strong>: <strong>少用一个元素空间</strong>, <strong>堆满条件: <code>(Rear + 1) % MaxSize == Front</code>; 队空: <code>Rear == Front</code></strong>.
应用:
多项式加法运算(用链表也可以, 返回结果多项式, 不改变原有多项式)
BFS</p></blockquote><p>(二) 栈和队列的顺序存储结构
(三) 栈和队列的链式存储结构
(四) 栈和队列的应用</p><p>顺序栈, <code>Top</code> 指针从 <code>-1</code> 开始, <code>MaxSize - 1</code> 为满</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>ElementType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>SNode</span> <span class=o>*</span><span class=n>PtrToSNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=o>*</span><span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>Top</span><span class=p>;</span>           <span class=cm>/*栈顶指针, -1 为空, MaxSize - 1 为满 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToSNode</span> <span class=n>Stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stack</span> <span class=nf>CreatStack</span><span class=p>(</span><span class=kt>int</span> <span class=n>MaxSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span> <span class=n>S</span> <span class=o>=</span> <span class=p>(</span><span class=n>Stack</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>SNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=p>(</span><span class=n>ElementType</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>MaxSize</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ElementType</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Top</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span> <span class=o>=</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>S</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Top</span> <span class=o>==</span> <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Push</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsFull</span><span class=p>(</span><span class=n>S</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;堆栈满&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=o>++</span><span class=p>(</span><span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Top</span><span class=p>)]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Top</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>Pop</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;堆栈空&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[(</span><span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Top</span><span class=p>)</span><span class=o>--</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>还有双栈, 最大化利用数组空间, 一个 <code>Top</code> 从 <code>-1</code> 开始, 另一个从 <code>MaxSize</code> 开始.</p><p>链栈, 头节点的 <code>Next</code> 就指向链表的头节点.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>SNode</span> <span class=o>*</span> <span class=n>PtrToSNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToSNode</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToSNode</span> <span class=n>Stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stack</span> <span class=nf>CreatStack</span><span class=p>(</span><span class=kt>int</span> <span class=n>MaxSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span> <span class=n>S</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>=</span> <span class=p>(</span><span class=n>Stack</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>SNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>S</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Push</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToSNode</span> <span class=n>TmpCell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TmpCell</span> <span class=o>=</span> <span class=p>(</span><span class=n>PtrToSNode</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>SNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>TmpCell</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TmpCell</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>TmpCell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>Pop</span><span class=p>(</span><span class=n>Stack</span> <span class=n>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;堆栈空&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>PtrToSNode</span> <span class=n>FirstCell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>TopElem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FirstCell</span> <span class=o>=</span> <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TopElem</span> <span class=o>=</span> <span class=n>FirstCell</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>FirstCell</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>FirstCell</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TopElem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>队列　<strong>数组实现</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>QNode</span> <span class=o>*</span> <span class=n>PtrToQNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>QNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=o>*</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>Front</span><span class=p>,</span> <span class=n>Rear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToQNode</span> <span class=n>Queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Queue</span> <span class=nf>CreateQueue</span><span class=p>(</span><span class=kt>int</span> <span class=n>MaxSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span> <span class=n>Q</span> <span class=o>=</span> <span class=p>(</span><span class=n>Queue</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>QNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=p>(</span><span class=n>ElementType</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>MaxSize</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ElementType</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span> <span class=o>=</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Q</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>)</span> <span class=p>{</span><span class=err>　</span><span class=k>return</span> <span class=p>((</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span> <span class=o>==</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Add</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsFull</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;队列满&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>)</span> <span class=p>{</span><span class=err>　</span><span class=k>return</span> <span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>==</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;队列空&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>链表实现, 不带头节点的链表实现队列</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>Node</span> <span class=o>*</span> <span class=n>PtrToNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToNode</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToNode</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>QNode</span> <span class=o>*</span> <span class=n>PtrToQNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>QNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>Front</span><span class=p>,</span> <span class=n>Rear</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToQNode</span> <span class=n>Queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Queue</span> <span class=nf>CreateQueue</span><span class=p>(</span><span class=kt>int</span> <span class=n>MaxSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span> <span class=n>Q</span> <span class=o>=</span> <span class=p>(</span><span class=n>Queue</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>QNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Q</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Add</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>Tmp</span> <span class=o>=</span> <span class=p>(</span><span class=n>Position</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Tmp</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Tmp</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>-&gt;</span> <span class=n>Next</span> <span class=o>=</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>)</span> <span class=p>{</span><span class=err>　</span><span class=k>return</span><span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>Queue</span> <span class=n>Q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>FrontCell</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>FrontElem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;队列空&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>FrontCell</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>==</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Rear</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> 
</span></span><span class=line><span class=cl>        <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>=</span> <span class=n>Q</span> <span class=o>-&gt;</span> <span class=n>Front</span> <span class=o>-&gt;</span> <span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>FrontElem</span> <span class=o>=</span> <span class=n>FrontCell</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>FrontCell</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>FrontElem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=二树与二叉树>二、树与二叉树</h4><p>(一) 树的基本概念</p><blockquote><p><code>Tree</code></p><p>树根, 子树, 父节点, <code>N-1</code> 条边, 森林 &mdash; 任何一棵树都是一个二元组 <code>Tree</code> = (<code>Root</code>, <code>Forest</code>)</p><p>结点的度: 子树的个数</p><p>树的度: 树所有结点中最大的度</p><p>叶节点: 度为 <code>0</code> 的结点</p><p>父节点: 具有子树, 则其为其子树根节点的父节点 ; 子节点: 与父节点相反</p><p>兄弟结点: 有同一父节点的彼此</p><p>祖先结点: 沿树根到某节点路径上的所有结点都是</p><p>子孙结点: 某结点的子树中的所有结点</p><p>结点的层次: <strong>根为 <code>1</code> , 其余为其父节点层数 <code>+1</code></strong></p><p>树的深度: <strong>所有结点中最大层次</strong></p><p>树的高度: <strong>其所有子节点的最大高度层数 <code>+1</code>, 叶节点为 <code>1</code></strong></p><p>分支: 两个相邻结点的分边</p><p>路径: 结点序列; <strong>路径长度: 路径包含的边数 = 结点数 - 1</strong></p></blockquote><p>(二) 二叉树
1. 二叉树的定义及其主要特性
2. 二叉树的顺序存储结构和链式存储结构
3. 二叉树的遍历</p><blockquote><p><code>Binary Tree</code></p><p>每个结点至多两个子树, 有左右序之分</p><p>斜二叉树(退化二叉树): 深度 <code>N</code>, 退化为线性表</p><p>完美二叉树(满二叉树): 所有分支结点都有左右子树, 且叶节点在同一层 $2^N - 1$</p><p>完全二叉树: 叶节点只会出现在最下层或次下层,且最下层叶节点都在左部</p><p><strong>对于任何非空二叉树: $n_0$ 为叶节点数, $n_2$ 为度为 <code>2</code> 的节点数, 则 $n_0= n_2+ 1$</strong></p><p>具有 <code>n</code> 个结点的完全二叉树深度 $\left \lfloor \log_2 n \right \rfloor +1$</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>TNode</span> <span class=o>*</span> <span class=n>BTPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>BTPosition</span> <span class=n>BinTree</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>OrderTraversal</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 此处加入判断叶节点, 则可实现遍历叶节点 */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 先序遍历 （根左右）*/</span>
</span></span><span class=line><span class=cl>        <span class=n>OrderTraversal</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 中序遍历 （左根右）*/</span>
</span></span><span class=line><span class=cl>        <span class=n>OrderTraversal</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 后序遍历 （左右根）*/</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InorderTraversal</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>T</span> <span class=o>=</span> <span class=n>BT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span> <span class=n>S</span> <span class=o>=</span> <span class=n>CreatStack</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>T</span> <span class=o>||</span> <span class=o>!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Push</span><span class=p>(</span><span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>Pop</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* T -&gt; Data 访问结点 */</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*层序遍历*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>LevellorderTraversal</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span> <span class=n>Q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BT</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Q</span> <span class=o>=</span> <span class=n>CreatQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>BT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>Delete</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 取出结点 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>)</span> <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>)</span> <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GetHight</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>HL</span><span class=p>,</span> <span class=n>HR</span><span class=p>,</span> <span class=n>MaxH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>HL</span> <span class=o>=</span> <span class=n>GetHight</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>HR</span> <span class=o>=</span> <span class=n>GetHight</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>MaxH</span> <span class=o>=</span> <span class=n>HL</span> <span class=o>&gt;</span> <span class=n>HR</span> <span class=o>?</span> <span class=nl>HL</span> <span class=p>:</span> <span class=n>HR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>MaxH</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*层序生成二叉树*/</span>
</span></span><span class=line><span class=cl><span class=n>BinTree</span> <span class=nf>CreatBinTree</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>BT</span><span class=p>,</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span> <span class=n>Q</span> <span class=o>=</span> <span class=n>CreatQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 输入根节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>Data</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BT</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>TNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>BT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>Delete</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>Data</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>TNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>Data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>Data</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=p>(</span><span class=n>BinTree</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>TNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>Add</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>(三) 树、森林
1. 树的存储结构 &ndash; 数组(根为 <code>1</code>),链表.
2. 森林与二叉树的转换
3. 树和森林的遍历</p><blockquote><p><strong>唯一确定一棵二叉树的方法</strong></p><p><strong>先序 / 后序 + 中序</strong></p><p>善于利用根的位置关系, 与子树大小</p></blockquote><blockquote><p>树与二叉树的转换</p><ol><li>兄弟结点之间连边</li><li>只保留第一个儿子的边</li><li>旋转调整为二叉树</li></ol><p>森林与二叉树的转换</p><ol><li>对每棵树各自转换为二叉树</li><li>每棵树的根节点看作兄弟结点, 连边</li><li>调整为二叉树</li></ol><p>二叉树转森林或树
若根节点有右儿子, 则转化为森林</p><ol><li>把根的右儿子断开, 根的右儿子的右儿子 &mldr; 断开</li><li>把各各部分转化为树</li><li>二叉树转树为上面的逆</li></ol></blockquote><blockquote><p>森林的遍历</p><p>理论上应当把森林转化为二叉树后遍历, 实际效果等同于一次对各棵树作各种遍历, 没有后序遍历</p></blockquote><p>(四) 树与二叉树的应用
1. 二叉排序树
2. 堆结构
3. 哈夫曼(Huffman) 树和哈夫曼编码</p><blockquote><p>二叉排序 / 搜索树
<strong>各键值彼此不同, 不会有重复元素</strong></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>TNode</span> <span class=o>*</span> <span class=n>BSTPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>BSTPosition</span> <span class=n>BinTree</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTree</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>OrderTraversal</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>BT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OrderTraversal</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>OrderTraversal</span><span class=p>(</span><span class=n>BT</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BSTPosition</span> <span class=nf>Find</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BST</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Find</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&lt;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Find</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>return</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BSTPosition</span> <span class=nf>FindMax</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BST</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>)</span> <span class=k>return</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>return</span> <span class=n>FindMax</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BSTPosition</span> <span class=nf>FindMin</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BST</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>BST</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>BST</span> <span class=o>=</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BSTPosition</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BST</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BST</span> <span class=o>=</span> <span class=p>(</span><span class=n>BSTPosition</span><span class=p>)</span> <span class=n>malloc</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>TNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&lt;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*X 已存在则什么都不做*/</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BinTree</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>BinTree</span> <span class=n>BST</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BSTPosition</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;要删除的元素未找到&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&lt;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>Delete</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>Delete</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span> <span class=c1>// 应当删除的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>&amp;&amp;</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Tmp</span> <span class=o>=</span> <span class=n>FindMin</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span> <span class=c1>// 找右子树的最小结点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>Tmp</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>Delete</span><span class=p>(</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>,</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=cm>/* 只有一个儿子或没有儿子 */</span>
</span></span><span class=line><span class=cl>                <span class=n>Tmp</span> <span class=o>=</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>)</span> <span class=c1>// 只有右儿子或者没有子结点(NULL), 
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>BST</span> <span class=o>=</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>BST</span> <span class=o>=</span> <span class=n>BST</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>free</span><span class=p>(</span><span class=n>Tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BST</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>堆结构 <code>Heap Priority Queue</code></p><p>起始单元为 <code>1</code>, 父节点 $\lfloor i / 2 \rfloor $, 子结点 $2i , 2i+1$</p><p>兄弟之间不存在约束关系</p><p><code>0</code> 可以放一个 <code>MAXDATA</code> 在插入时可以有用, 可以自动在 <code>0</code>处跳出循环</p><p>删除是用数组的最后一个元素放到根节点上再调整</p><p>建立: 从第 $\lfloor n / 2 \rfloor $个结点开始(最后一个有儿子的结点) O(N)</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>HNode</span> <span class=o>*</span><span class=n>Heap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>HNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=o>*</span><span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Heap</span> <span class=n>MaxHeap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define MaxData 998244353 </span><span class=cm>/* 比所有元素大或小的元素作为哨兵 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>MaxHeap</span> <span class=nf>CreatHeap</span><span class=p>(</span><span class=kt>int</span> <span class=n>MaxSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MaxHeap</span> <span class=n>H</span> <span class=o>=</span> <span class=p>(</span><span class=n>MaxHeap</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>HNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=p>(</span><span class=n>ElementType</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>((</span><span class=n>MaxSize</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ElementType</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Capacity</span> <span class=o>=</span> <span class=n>MaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>MaxData</span><span class=p>;</span> <span class=cm>/* 设置哨兵 */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>H</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span> <span class=o>==</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Capacity</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsFull</span><span class=p>(</span><span class=n>H</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;最大堆已满&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=o>++</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>;</span> <span class=cm>/* 指向应当插入的位置 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 上滤 X */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span> <span class=p>;</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>idx</span> <span class=o>/</span> <span class=mi>2</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>X</span><span class=p>;</span> <span class=n>idx</span> <span class=o>/=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>idx</span> <span class=o>/</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>DeleteMax</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Parent</span><span class=p>,</span> <span class=n>Child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>MaxItem</span><span class=p>,</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>H</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;最大堆为空&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>MaxItem</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span> <span class=o>--</span><span class=p>];</span> <span class=cm>/* 规模减小并且取出最后元素 */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>Parent</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>&lt;=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>;</span> <span class=n>Parent</span> <span class=o>=</span> <span class=n>Child</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Child</span> <span class=o>=</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Child指向左右儿子中大的 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>Child</span> <span class=o>!=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]))</span> 
</span></span><span class=line><span class=cl>            <span class=n>Child</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 找到位置 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>])</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 下滤 X */</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>MaxItem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 将以 p 为根的子堆调整为最大堆 */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PercDown</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Parent</span><span class=p>,</span> <span class=n>Child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>Parent</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>&lt;=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>;</span> <span class=n>Parent</span> <span class=o>=</span> <span class=n>Child</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Child</span> <span class=o>=</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>Child</span> <span class=o>!=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]))</span> 
</span></span><span class=line><span class=cl>            <span class=n>Child</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>])</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Child</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BuildHeap</span><span class=p>(</span><span class=n>MaxHeap</span> <span class=n>H</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>--</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>PercDown</span><span class=p>(</span><span class=n>H</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><ol start=3><li>哈夫曼(Huffman) 树和哈夫曼编码</li></ol><p>设 <code>n</code> 结点的树, 叶节点带权值 $W_k$, 从根到叶的长度 $l_k$, 则树的带权路径长度 <code>WPL</code> = $\sum_{k=1}^{n} W_k L_k$</p><p>树形可能不同, WPL 最小</p><p>复杂度 O(NlogN)</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>HTNode</span> <span class=o>*</span><span class=n>HuffmanTree</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>HTNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HuffmanTree</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HuffmanTree</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>HuffmanTree</span> <span class=nf>Huffman</span><span class=p>(</span><span class=n>MinHeap</span> <span class=n>H</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HuffmanTree</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BuildHeap</span><span class=p>(</span><span class=n>H</span><span class=p>);</span> <span class=cm>/* 调整 O(N)*/</span>
</span></span><span class=line><span class=cl>    <span class=n>N</span> <span class=o>=</span> <span class=n>H</span> <span class=o>-&gt;</span> <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 作 Size - 1 次合并 */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=n>HuffmanTree</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>HTNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>DeleteMin</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>DeleteMin</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Weight</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Weight</span> <span class=o>+</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>-&gt;</span> <span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Insert</span><span class=p>(</span><span class=n>H</span><span class=p>,</span> <span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>DeleteMin</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=三图>三、图</h4><p>(一) 图的基本概念</p><blockquote><p>Graph</p><p>非空有限集合 V, 边集合 E, G = (V, E), 数据对象是顶点</p><p>无向图: (v, w)</p><p>有向图: &lt;v, w></p><p>简单图: 无重边, 无回路, <strong>我们考虑的都是简单图</strong></p><p>邻接点: 边的端点互为邻接点, &lt;v, w> v 邻接到 w, w 邻接自 v</p><p>路径: 顶点序列, 相邻顶点间在图中有边</p><p>简单路径: 除了首位顶点外, 其余顶点都不同</p><p>回(环)路: 起点 == 终点; 简单回路: 简单路径的回路 (自环是自回路); 无向图的环路 >= 3 ; 有向图不存在回路 -> 无环图</p><p>无向完全图: 任意两点都有边相连 $n(n-1)/2$; 有向完全图: 任意两点都有互为相反的两条弧相连 $n(n-1)$</p><p>顶点的度: 该点边数; 入度 + 出度 = 度; 图的总入度 = 总出度 = 一半的度</p><p>稠密图: 边数接近完全图; 稀疏图: 边数很少的图</p><p>设图 G(V, E), 边数 |E|, 定点数 |V|;</p><p>稠密图: 平均顶点度与顶点数目成正比的图 $|E| = k|V|^2( 0 &lt; k &lt; 1/2)$
或者 $|E| > |V| \log_2|V|$</p><p>权: 边上的权值; 网图: 边上带权的图</p><p>子图: G&rsquo;(V&rsquo;, E')</p><p>连通图: 无向图中, 如果任意两点是连通的; 连通分量: 无向图的极大连通分量</p><ol><li>子图;</li><li>连通;</li><li>极大顶点数: 再加点会不连通;</li><li>极大边数: 包含依附于这些顶点的所有边</li></ol><p>连通的无向图只有一个连通分量(本图)</p><p>强连通图: 有向图中, 如果任意两点是连通的(双向路径);</p><p>强连通分量: 有向图的极大连通分量</p><p>连通的有向图只有一个连通分量(本图)</p><p>生成树: 连通图, 包含全部顶点的极小连通子图</p><p>有向图生成树: 恰有一个顶点的入度为 <code>0</code>(根), 其余点入度为 <code>1</code></p><p>生成森林: 一个生成树对应一个连通分量</p><p>对无向图而言, 连通分量数 == 生成森林中树数</p><p>对有向图而言, 非强连通图也可能只需要一棵生成树与之对应</p></blockquote><p>(二) 图的存储及基本操作</p><ol><li>邻接矩阵法</li><li>邻接表法</li><li>邻接多重表、十字链表</li></ol><blockquote><p>邻接矩阵法</p><p>网图中 $\infty$ 代表不存在边</p><p>无向图所需存储元素个数 $|V| \times (|V| - 1) / 2$</p><p>优点: 很容易确定两点之间是否有边, 数邻接点只要遍历行或列</p><p>局限性: 数边数, 需要 $O(N^2)$</p></blockquote><blockquote><p>邻接表法</p><p>顶点表数组(顶点域 + 表头指针) + 链表(邻接点域 + 指针域)</p><p>采用的是头插法</p><p>优点: 节约空间, 无向图中, 顶点的度恰为链表的结点数, 有向图中为出度</p><p>缺点: 求有向图的入度很麻烦, 需要遍历全图(可以建逆邻接表优化) ; 判断 $v_i$ 与 $v_j$ 间是否有边不如邻接矩阵</p><p>若输入的定点信息为顶点的编号, 则建表复杂度 O(|v| + |E|), 否在 O(|V| + |E|)</p></blockquote><blockquote><p>邻接多重表、十字链表</p><p>十字链表 P70</p><p>邻接多重表: 邻接表 , 链表信息增加</p><p>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</p></blockquote><p><code>ivex</code> 和 <code>jvex</code>：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</p><p><code>ilink</code>：指针域，指向下一个存储与 <code>ivex</code> 有直接关联顶点的节点；</p><p><code>jlink</code>：指针域，指向下一个存储与 <code>jvex</code> 有直接关联顶点的节点；</p><p><code>info</code>：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；</p><p>(三) 图的遍历</p><ol><li>深度优先搜索</li><li>广度优先搜索</li></ol><blockquote><p>DFS</p><p>邻接矩阵 O($|V|^2$); 邻接表 O(|V| + |E|)</p><p>BFS</p><p>邻接矩阵 O($|V|^2$); 邻接表 O(|V| + |E|)</p></blockquote><p>(四) 图的基本应用</p><ol><li>最小(代价) 生成树</li><li>最短路径</li><li>拓扑排序</li></ol><blockquote><p>MST
Prim</p><p>不断更新dist, 每次添加最小的 dist 的点, O($|V|^2$), 稠密图效果好
用堆优化查找最小 dist的过程, 可以得到和 Kruskal 一样的复杂度 O($|E|\log|V|$)</p><p>Kruskal</p><p>适合稀疏图</p><p>高效排序下, 复杂度 O($|E|\log|V|$)</p></blockquote><blockquote><p>最短路 不能处理负权</p><p>Dijkstra</p><p>O($|V|^2$), 稠密图效果好, 堆优化 O($|E|\log|V|$)</p><p>Floyd</p><p>O($|V|^3$) 多源最短路</p></blockquote><blockquote><p>TopOrder</p><p>邻接表 + 队列优化 复杂度 O(|E| + |V|)</p></blockquote><h4 id=四动态查找>四、动态查找</h4><p>(一) 平衡二叉树(AVL树)
(二) 散列(Hash) 表
(三) 查找算法的分析及应用</p><blockquote><p>AVL
平衡因子 $BF = h_L - h_R$, 不能超过 <code>1</code>, 所有在 <code>-1 0 1</code>之间</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>AVLNode</span> <span class=o>*</span> <span class=n>AVLPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>AVLPosition</span> <span class=n>AVLTree</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>AVLNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AVLTree</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AVLTree</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Max</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GetHeight</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>T</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Height</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=cm>/* 左单旋 */</span>
</span></span><span class=line><span class=cl><span class=n>AVLTree</span> <span class=nf>SingleLeftRotataion</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>A</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AVLTree</span> <span class=n>B</span> <span class=o>=</span> <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=n>Max</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>),</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=n>Max</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>),</span> <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Height</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* 右单旋 */</span>
</span></span><span class=line><span class=cl><span class=n>AVLTree</span> <span class=nf>SingleRightRotataion</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>A</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AVLTree</span> <span class=n>B</span> <span class=o>=</span> <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=n>Max</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>),</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=n>Max</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>B</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>),</span> <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Height</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* 左-右 双旋 */</span>
</span></span><span class=line><span class=cl><span class=n>AVLTree</span> <span class=nf>DoubleLeftRightRotation</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>A</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 先对左子树作右旋，再对整棵树作左旋 */</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>SingleRightRotataion</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>SingleLeftRotataion</span><span class=p>(</span><span class=n>A</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* 右-左 双旋 */</span>
</span></span><span class=line><span class=cl><span class=n>AVLTree</span> <span class=nf>DoubleRightLeftRotation</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>A</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>SingleLeftRotataion</span><span class=p>(</span><span class=n>A</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>SingleRightRotataion</span><span class=p>(</span><span class=n>A</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>AVLTree</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>AVLTree</span> <span class=n>T</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 若插入空树，则新建结点 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=n>AVLTree</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>AVLNode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Data</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&lt;</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=cm>/* 插入到左子树 */</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 判断树是否平衡 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>)</span> <span class=o>-</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 通过 X 与左子树的值的大小判断旋转方式*/</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&lt;</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>T</span> <span class=o>=</span> <span class=n>SingleLeftRotataion</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>T</span> <span class=o>=</span> <span class=n>DoubleLeftRightRotation</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>)</span> <span class=o>-</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;</span> <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span> <span class=o>-&gt;</span> <span class=n>Data</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                <span class=n>T</span> <span class=o>=</span> <span class=n>SingleRightRotataion</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>T</span> <span class=o>=</span> <span class=n>DoubleRightLeftRotation</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* X == T -&gt; Data 无需插入 */</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Height</span> <span class=o>=</span> <span class=n>Max</span><span class=p>(</span><span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Left</span><span class=p>),</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>T</span> <span class=o>-&gt;</span> <span class=n>Right</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>散列(Hash) 表</p><p>类型: 符号表, 散列表, hash表</p><p>散列函数(hash 函数): h(key)</p><p>装填因子 $\alpha$: 填入表的元素 / 空间大小 ; 分链法 -> 每个链表的平均长度
$\alpha = 0.5$ ~ $0.8$ 为宜</p><p>好的散列表: 1. 转换速度快 2. 冲突小</p><p>数字关键字的散列表</p><ol><li>直接定址法</li></ol><p>$h(key) = a \times key + b$</p><p>不会有冲突, 但要求地址和关键字集合大小一致, 大集合不适合用</p><ol start=2><li>除留余数法</li></ol><p>TableSize = 集合大小 $n$ / 允许最大装填因子 $\alpha$</p><p>简单情况: h(key) = key % p(小于等于 TableSize 的素数, 素数均匀分布可能性大)</p><ol start=3><li>数字分析法</li></ol><p>特殊情况特殊处理的函数</p><p>字符串关键字的散列表</p><ol><li>ASCII 码加和法</li></ol><p>简单, 均匀性差</p><ol start=2><li>前三个字符移位法</li></ol><p>$h(key) = (ksy[0] + key[1] \times 27 + key[2] \times 27^2) mod TableSize$</p><p>26 字符 + 空格 = 27</p><p>冲突, 空间浪费严重 $\alpha$ 不到 30%</p><ol start=3><li>移位法</li></ol><p>$h(key) = (\sum_{i=0}^{n-1} key[n-i-1] \times 32^i) \mod TableSize$</p><p>每个字符占 5 位, 所以为 32, 用 <code>H &lt;&lt; 5</code> 实现</p><p>n 过大, 前面若干位可能移出界, 可以选有代表性的字符, 如大于 12 时选奇数位</p><p><strong>冲突处理</strong></p><p>开放寻址法</p><p>发生第 i 次冲突, 试探的下一个地址加 $d_i$</p><p>$h_i (key) = (h(key) + d_i) \mod TableSize$</p><p>删除会引起冲突, 所以要懒标记删除</p><p><strong>平均查找长度 ASL</strong> = $\sum 每个关键字的比较次数 / 关键字个数$</p><ol><li>线性探测法</li></ol><p>$d_i \in 1, 2, \dots , TableSize - 1$</p><p>会出现需要多次冲突才能找到空位, 这种现象叫一次聚集</p><ol start=2><li>平方探测法</li></ol><p>$d_i = \pm i^2, 1^2, -1^2, 2^2, -2^2, \dots q^2, -q^2, q \leqslant \lfloor TableSize / 2 \rfloor$</p><p>如果 TableSize 是某个 $4k + 3$ 形式的素数的话, 平方探测法就可以探测到整个散列空间</p><p>散列到同一地址的会探测相同备选单元叫 二次集聚</p><ol start=3><li>双散列探测法</li></ol><p>$d_i = i \times h_2(key)$</p><p>一般 $h_2(key) = p - (key \mod p)$</p><p>增加了计算</p><ol start=4><li>再散列法</li></ol><p>装填因子过大时, 新建一个越来两倍的散列表, 旧数据从新分到新表, 可能出现停顿</p><p>分离链接法</p><p>散列表地址作为指针, 指向一个链表</p></blockquote><blockquote><p>查找算法的分析及应用</p><p>顺序查找 O(N)</p><p>二分查找 O(log N)</p><p>二叉搜索树 最坏 O(N), 最好 O(log N)</p><p>AVL O(log N)</p></blockquote><h4 id=五排序>五、排序</h4><p>(一) 希尔排序(Shell Sort)</p><p>(二) 快速排序</p><p>(三) 堆排序</p><p>(四) 二路归并排序(Merge Sort)</p><p>(五) 基数排序</p><p>(六) 各种内部排序算法的比较</p><p>(七) 排序算法的应用</p><blockquote><p>简单选择排序 时间 O(N^2), 空间 O(1)</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>SimpleSelect</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>min</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>min</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>j</span> <span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>min</span><span class=p>])</span> <span class=n>min</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>min</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>堆排序</p><p>时间 O(NlogN), 空间 从 O(N) 优化到 O(1)(最后一个元素与堆顶交换)
与堆不同的是, 这里的下标是 <code>0</code> 开始的, 所以左儿子 <code>2i + 1</code>, 右儿子 <code>2i + 2</code>, 父节点 $\lfloor (i-1)/2\rfloor$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PercDown</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 将 A[p] 为根的子堆调整 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Parent</span><span class=p>,</span> <span class=n>Child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>Parent</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=p>(</span><span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>Parent</span> <span class=o>=</span> <span class=n>Child</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Child</span> <span class=o>=</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>Child</span> <span class=o>!=</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>Child</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>[</span><span class=n>Child</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>            <span class=n>Child</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>X</span> <span class=o>&gt;=</span> <span class=n>A</span><span class=p>[</span><span class=n>Child</span><span class=p>])</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>A</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>Child</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>HeapSort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>N</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>--</span><span class=p>)</span> <span class=cm>/* 建立最大堆 */</span>
</span></span><span class=line><span class=cl>        <span class=n>PercDown</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>N</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>PercDown</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>插入排序</p><p>时间 O(N^2), 空间 O(1), 稳定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InsertionSort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>P</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>P</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>P</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>P</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Tmp</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>P</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>P</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>Tmp</span><span class=p>;</span> <span class=n>i</span> <span class=o>--</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>希尔排序</p><p>时间最差 O(N^2), 理想 {1, 3, 7, $2^k-1$} $O(N^{5\over 4})$, 最差 $O(N^{3\over 2})$ 空间 O(1)
最后一个增量为 1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ShellSOrt</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Si</span><span class=p>,</span> <span class=n>D</span><span class=p>,</span> <span class=n>P</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Sedgewick</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>929</span><span class=p>,</span> <span class=mi>505</span><span class=p>,</span> <span class=mi>209</span><span class=p>,</span> <span class=mi>109</span><span class=p>,</span> <span class=mi>41</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>Si</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>Sedgewick</span><span class=p>[</span><span class=n>Si</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>N</span><span class=p>;</span> <span class=n>Si</span> <span class=o>++</span><span class=p>)</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>D</span> <span class=o>=</span> <span class=n>Sedgewick</span><span class=p>[</span><span class=n>Si</span><span class=p>];</span> <span class=n>D</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>D</span> <span class=o>=</span> <span class=n>Sedgewick</span><span class=p>[</span><span class=o>++</span><span class=n>Si</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 插入排序 */</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span> <span class=n>P</span> <span class=o>=</span> <span class=n>D</span><span class=p>;</span> <span class=n>P</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>P</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Tmp</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>P</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>P</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>D</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=n>D</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>Tmp</span><span class=p>;</span> <span class=n>i</span> <span class=o>-=</span> <span class=n>D</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>D</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span><span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>冒泡排序</p><p>时间 O(N^2), 空间 O(1), 稳定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BubbleSort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>P</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>P</span> <span class=o>=</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>P</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>P</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>P</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>flag</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>快速排序</p><p>时间 O($N\log N$) 最坏 O($N^2$), 空间最坏 O(N) 栈空间</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 选中值 */</span>
</span></span><span class=line><span class=cl><span class=n>ElementType</span> <span class=nf>Median3</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>Left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Center</span> <span class=o>=</span> <span class=p>(</span><span class=n>Left</span> <span class=o>+</span> <span class=n>Right</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>Left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>A</span><span class=p>[</span><span class=n>Center</span><span class=p>])</span> <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Left</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Center</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>Left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>A</span><span class=p>[</span><span class=n>Right</span><span class=p>])</span> <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Left</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Right</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>Center</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>A</span><span class=p>[</span><span class=n>Right</span><span class=p>])</span> <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Center</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Right</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* A[Left] &lt;= A[Center] &lt;= A[Right] 所以中值 A[Center]作为基准 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Center</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]);</span> <span class=cm>/*将基准藏到右边, 只需考虑, left + 1 ... right - 2*/</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>A</span><span class=p>[</span><span class=n>Right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Qsort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>Left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Pivot</span><span class=p>,</span> <span class=n>Cutoff</span><span class=p>,</span> <span class=n>Low</span><span class=p>,</span> <span class=n>High</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 如果元素够多进入快排 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>Cutoff</span> <span class=o>&lt;=</span> <span class=n>Right</span> <span class=o>-</span> <span class=n>Left</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Pivot</span> <span class=o>=</span> <span class=n>Median3</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>Left</span><span class=p>,</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Low</span> <span class=o>=</span> <span class=n>Left</span><span class=p>;</span> <span class=n>High</span> <span class=o>=</span> <span class=n>High</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=o>++</span><span class=n>Low</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>Pivot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=o>--</span><span class=n>High</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>Pivot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>Low</span> <span class=o>&lt;</span> <span class=n>High</span><span class=p>)</span> <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Low</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>High</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Low</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>Right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]);</span> <span class=cm>/* 把基准换到正确的位置 */</span>
</span></span><span class=line><span class=cl>        <span class=n>Qsort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>Left</span><span class=p>,</span> <span class=n>Low</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Qsort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>Low</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>Right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>InsertionSort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>Right</span> <span class=o>-</span> <span class=n>Left</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>归并排序</p><p>时间 O($N\log N$) , 空间 O(N) ,如果在递归中建数组,则空间消耗为 O($N\log N$);</p><p>稳定, 常用于外部排序, 而非内部</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Merge</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=n>ElementType</span> <span class=n>TmpA</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>R</span><span class=p>,</span> <span class=kt>int</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>LeftEnd</span><span class=p>,</span> <span class=n>NumElements</span><span class=p>,</span> <span class=n>Tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*L ~ R - 1 与 R ~ RightEnd 合并为有序*/</span>
</span></span><span class=line><span class=cl>    <span class=n>LeftEnd</span> <span class=o>=</span> <span class=n>R</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=cm>/*左边终点*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Tmp</span> <span class=o>=</span> <span class=n>L</span><span class=p>;</span>         <span class=cm>/*序列起点*/</span>
</span></span><span class=line><span class=cl>    <span class=n>NumElements</span> <span class=o>=</span> <span class=n>RightEnd</span> <span class=o>-</span> <span class=n>L</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*复制数组*/</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>L</span> <span class=o>&lt;=</span> <span class=n>LeftEnd</span> <span class=o>&amp;&amp;</span> <span class=n>R</span> <span class=o>&lt;=</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>L</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>A</span><span class=p>[</span><span class=n>R</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>TmpA</span><span class=p>[</span><span class=n>Tmp</span> <span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>L</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>TmpA</span><span class=p>[</span><span class=n>Tmp</span> <span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>R</span><span class=o>++</span><span class=p>];;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>L</span> <span class=o>&lt;=</span> <span class=n>LeftEnd</span><span class=p>)</span> <span class=n>TmpA</span><span class=p>[</span><span class=n>Tmp</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>L</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>R</span> <span class=o>&lt;=</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=n>TmpA</span><span class=p>[</span><span class=n>Tmp</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>R</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NumElements</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>,</span> <span class=n>RightEnd</span> <span class=o>--</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=p>[</span><span class=n>RightEnd</span><span class=p>]</span> <span class=o>=</span> <span class=n>TmpA</span><span class=p>[</span><span class=n>RightEnd</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Msort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=n>ElementType</span> <span class=n>TmpA</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Center</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>L</span> <span class=o>&lt;</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Center</span> <span class=o>=</span> <span class=p>(</span><span class=n>L</span> <span class=o>+</span> <span class=n>RightEnd</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Msort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>TmpA</span><span class=p>,</span> <span class=n>L</span><span class=p>,</span> <span class=n>Center</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>Msort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>TmpA</span><span class=p>,</span> <span class=n>Center</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>RightEnd</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>Merge</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>TmpA</span><span class=p>,</span> <span class=n>L</span><span class=p>,</span> <span class=n>Center</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>RightEnd</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=o>*</span><span class=n>TmpA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TmpA</span> <span class=o>=</span> <span class=p>(</span><span class=n>ElementType</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>N</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>ElementType</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>TmpA</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Msort</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>TmpA</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>TmpA</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>桶排序</p><p>N 个数据, M 个桶, 时间复杂度 O(N + M)</p><p>基数排序
对于有 k 个关键字的情况有</p><ol><li>主位优先法 MSD</li><li>次位优先法 LSD</li></ol><p>一般情况下次位优先效率高</p><p>分配收集趟数: D, 关键字 N, 桶: R</p><p>时间 O(D(N + R))</p><p>由于链表操作, O(N) 常数项可能超过 Log N, 且需要额外 O(N) 空间, 稳定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MaxDigit 4
</span></span></span><span class=line><span class=cl><span class=cp>#define Radix 10
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*桶元素结点*/</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>Node</span> <span class=o>*</span> <span class=n>PtrToNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToNode</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cm>/*桶头结点*/</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>HeadNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToNode</span> <span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>HeadNode</span> <span class=n>Bucket</span><span class=p>[</span><span class=n>Radix</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*返回某数的第 D 位数字*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GetDigit</span><span class=p>(</span><span class=kt>int</span> <span class=n>X</span><span class=p>,</span> <span class=kt>int</span> <span class=n>D</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>d</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>D</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>d</span> <span class=o>=</span> <span class=n>X</span> <span class=o>%</span> <span class=n>Radix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>X</span> <span class=o>/=</span> <span class=n>Radix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>LSDRadixSort</span><span class=p>(</span><span class=n>ElementType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>D</span><span class=p>,</span> <span class=n>Di</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Bucket</span> <span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToNode</span> <span class=n>tmp</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>List</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>Radix</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=n>B</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>head</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>tail</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=p>(</span><span class=n>PtrToNode</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>key</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>D</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>D</span> <span class=o>&lt;=</span> <span class=n>MaxDigit</span><span class=p>;</span> <span class=n>D</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*分配*/</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Di</span> <span class=o>=</span> <span class=n>GetDigit</span><span class=p>(</span><span class=n>p</span> <span class=o>-&gt;</span> <span class=n>key</span><span class=p>,</span> <span class=n>D</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>head</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>head</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>tail</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>tail</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>tail</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*收集*/</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>Di</span> <span class=o>=</span> <span class=n>Radix</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>Di</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>Di</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>tail</span> <span class=o>-&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>List</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>head</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>Di</span><span class=p>].</span><span class=n>tail</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span> <span class=o>=</span> <span class=n>List</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span> <span class=o>-&gt;</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 sy ^_^</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>